{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Refactoring des entités Player dans le domaine",
        "description": "Unifier et séparer les entités Player dupliquées en GamePlayer et LobbyPlayer distincts, en supprimant toute logique de sérialisation des entités du domaine",
        "details": "1. Créer deux entités distinctes dans domain/entities: GamePlayer (pour le jeu actif avec grille, score, position) et LobbyPlayer (pour la salle d'attente avec statut ready, nom). 2. Utiliser Freezed pour l'immutabilité SANS json_serializable dans le domaine. 3. Supprimer toute référence à fromJson/toJson dans les entités. 4. Implémenter les mappers GamePlayerModel ↔ GamePlayer et LobbyPlayerModel ↔ LobbyPlayer dans la couche data. 5. Mettre à jour tous les use cases et repositories pour utiliser les bonnes entités. Code exemple: @freezed class GamePlayer with _$GamePlayer { const factory GamePlayer({required String id, required String name, required PlayerGrid grid, required int score, required PlayerPosition position}) = _GamePlayer; }",
        "testStrategy": "Tests unitaires pour valider l'immutabilité des entités, tests des mappers pour vérifier la conversion bidirectionnelle, tests d'intégration pour valider que les use cases fonctionnent avec les nouvelles entités. Vérifier qu'aucune méthode de sérialisation n'existe dans le domaine.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer l'entité GamePlayer dans le domaine",
            "description": "Implémenter l'entité GamePlayer avec Freezed dans domain/entities sans aucune logique de sérialisation",
            "dependencies": [],
            "details": "Créer lib/features/game/domain/entities/game_player.dart avec @freezed class GamePlayer contenant: id (String), name (String), grid (PlayerGrid), score (int), position (PlayerPosition), isReady (bool), hasKnocked (bool). Utiliser uniquement Freezed pour l'immutabilité, sans json_serializable. Implémenter les méthodes copyWith générées par Freezed. S'assurer que PlayerGrid et PlayerPosition sont des entités pures du domaine.",
            "status": "pending",
            "testStrategy": "Tests unitaires pour valider l'immutabilité de GamePlayer, tests de création avec différentes valeurs, tests copyWith pour vérifier les modifications, vérifier l'absence de méthodes fromJson/toJson"
          },
          {
            "id": 2,
            "title": "Créer l'entité LobbyPlayer dans le domaine",
            "description": "Implémenter l'entité LobbyPlayer avec Freezed dans domain/entities pour la gestion des joueurs en salle d'attente",
            "dependencies": [],
            "details": "Créer lib/features/multiplayer/domain/entities/lobby_player.dart avec @freezed class LobbyPlayer contenant: id (String), name (String), isReady (bool), isHost (bool), avatarUrl (String?). Utiliser Freezed sans json_serializable. Ajouter des factory constructors pour les cas d'usage courants (guest, host). Implémenter une méthode toGamePlayer() pour la conversion lors du démarrage de partie.",
            "status": "pending",
            "testStrategy": "Tests unitaires de création et modification de LobbyPlayer, tests des factory constructors, tests de la méthode toGamePlayer avec valeurs par défaut pour grid et score"
          },
          {
            "id": 3,
            "title": "Implémenter les modèles et mappers GamePlayer",
            "description": "Créer GamePlayerModel dans la couche data avec json_serializable et implémenter les mappers bidirectionnels",
            "dependencies": [
              "1.1"
            ],
            "details": "Créer lib/features/game/data/models/game_player_model.dart avec @JsonSerializable() et tous les champs de GamePlayer. Implémenter toEntity() pour convertir vers GamePlayer du domaine. Créer une extension GamePlayerMapper sur GamePlayer avec toModel(). Gérer la conversion des objets imbriqués (PlayerGridModel, PlayerPositionModel). Ajouter les factories fromJson/toJson générées.",
            "status": "pending",
            "testStrategy": "Tests round-trip complets GamePlayer -> GamePlayerModel -> GamePlayer, tests avec différentes valeurs de grid et position, tests de sérialisation JSON, vérification de la préservation de toutes les données"
          },
          {
            "id": 4,
            "title": "Implémenter les modèles et mappers LobbyPlayer",
            "description": "Créer LobbyPlayerModel dans la couche data avec json_serializable et implémenter les mappers bidirectionnels",
            "dependencies": [
              "1.2"
            ],
            "details": "Créer lib/features/multiplayer/data/models/lobby_player_model.dart avec @JsonSerializable(). Implémenter toEntity() retournant LobbyPlayer. Créer extension LobbyPlayerMapper sur LobbyPlayer avec toModel(). Gérer les champs nullable correctement (avatarUrl). Ajouter support pour la conversion depuis/vers les réponses Supabase.",
            "status": "pending",
            "testStrategy": "Tests de conversion bidirectionnelle, tests avec avatarUrl null/non-null, tests de compatibilité avec format JSON Supabase, validation des valeurs booléennes"
          },
          {
            "id": 5,
            "title": "Migrer les use cases et repositories vers les nouvelles entités",
            "description": "Mettre à jour tous les use cases et repositories pour utiliser GamePlayer/LobbyPlayer au lieu de Player",
            "dependencies": [
              "1.3",
              "1.4"
            ],
            "details": "Identifier tous les fichiers utilisant l'ancienne entité Player via grep/recherche. Remplacer Player par GamePlayer dans: game repositories, game use cases (StartGame, EndTurn, etc.), game state. Remplacer Player par LobbyPlayer dans: room repositories, lobby use cases (JoinRoom, ToggleReady). Adapter les signatures de méthodes et les imports. Supprimer l'ancienne entité Player après migration complète.",
            "status": "pending",
            "testStrategy": "Tests d'intégration pour vérifier le flux complet lobby -> game, tests unitaires des use cases modifiés, vérification que l'ancienne entité Player n'est plus référencée, tests de non-régression sur les fonctionnalités critiques"
          }
        ]
      },
      {
        "id": 2,
        "title": "Migration de DbPlayerGrid vers la couche data",
        "description": "Déplacer DbPlayerGrid de la couche domain vers data car elle contient de la logique de sérialisation, violant les principes de Clean Architecture",
        "details": "1. Déplacer lib/features/game/domain/entities/db_player_grid.dart vers lib/features/game/data/models/db_player_grid_model.dart. 2. Renommer la classe en DbPlayerGridModel. 3. Créer une entité PlayerGrid pure dans domain sans sérialisation. 4. Implémenter les mappers DbPlayerGridModel ↔ PlayerGrid. 5. Mettre à jour toutes les références dans les repositories et datasources. 6. Adapter les requêtes Supabase pour utiliser DbPlayerGridModel. Utiliser json_serializable uniquement dans la couche data.",
        "testStrategy": "Tests unitaires pour la nouvelle entité PlayerGrid, tests des mappers de conversion, tests d'intégration avec Supabase pour valider la persistance. Vérifier que l'entité domain ne contient aucune annotation json_serializable.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Déplacer et renommer DbPlayerGrid vers la couche data",
            "description": "Migrer le fichier DbPlayerGrid de domain/entities vers data/models et renommer la classe en DbPlayerGridModel",
            "dependencies": [],
            "details": "1. Créer le répertoire lib/features/game/data/models s'il n'existe pas. 2. Déplacer lib/features/game/domain/entities/db_player_grid.dart vers lib/features/game/data/models/db_player_grid_model.dart. 3. Renommer la classe DbPlayerGrid en DbPlayerGridModel. 4. Mettre à jour les imports dans le fichier. 5. Conserver toutes les annotations json_serializable existantes car elles sont appropriées dans la couche data.",
            "status": "pending",
            "testStrategy": "Vérifier que le fichier est bien déplacé, que la classe est renommée correctement, et que les annotations json_serializable sont préservées. Exécuter build_runner pour s'assurer que la génération de code fonctionne."
          },
          {
            "id": 2,
            "title": "Créer l'entité PlayerGrid pure dans domain",
            "description": "Implémenter une nouvelle entité PlayerGrid sans logique de sérialisation dans la couche domain",
            "dependencies": [],
            "details": "1. Créer lib/features/game/domain/entities/player_grid.dart. 2. Définir la classe PlayerGrid avec uniquement les propriétés métier (playerId, cards, revealedPositions, etc.). 3. Utiliser Freezed pour l'immutabilité mais sans json_serializable. 4. Implémenter les méthodes métier comme revealCard(), replaceCard(), isColumnComplete(). 5. Assurer que l'entité ne contient aucune dépendance vers la couche data.",
            "status": "pending",
            "testStrategy": "Tests unitaires pour toutes les méthodes métier de PlayerGrid. Vérifier l'immutabilité avec Freezed. S'assurer qu'aucune annotation json_serializable n'est présente dans le fichier."
          },
          {
            "id": 3,
            "title": "Implémenter les mappers bidirectionnels",
            "description": "Créer les fonctions de conversion entre PlayerGrid (domain) et DbPlayerGridModel (data)",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "1. Dans db_player_grid_model.dart, ajouter une méthode toEntity() qui convertit DbPlayerGridModel vers PlayerGrid. 2. Ajouter une factory DbPlayerGridModel.fromEntity(PlayerGrid entity) pour la conversion inverse. 3. Gérer la conversion des types complexes comme les listes de cartes. 4. S'assurer que les positions révélées sont correctement mappées. 5. Traiter les cas null de manière appropriée.",
            "status": "pending",
            "testStrategy": "Tests unitaires exhaustifs pour les deux sens de conversion. Vérifier la préservation de toutes les données lors des conversions. Tests avec des cas limites (listes vides, valeurs null)."
          },
          {
            "id": 4,
            "title": "Mettre à jour les repositories et datasources",
            "description": "Adapter tous les repositories et datasources pour utiliser les nouveaux types",
            "dependencies": [
              "2.3"
            ],
            "details": "1. Mettre à jour GameStateRepository pour utiliser PlayerGrid dans les signatures de méthodes. 2. Modifier SupabaseGameStateDataSource pour travailler avec DbPlayerGridModel. 3. Appliquer les mappers dans les implémentations de repository pour convertir entre les couches. 4. Mettre à jour les imports dans tous les fichiers affectés. 5. Adapter les requêtes Supabase pour sérialiser/désérialiser DbPlayerGridModel.",
            "status": "pending",
            "testStrategy": "Tests d'intégration pour vérifier que les données transitent correctement entre les couches. Mocker Supabase pour tester les conversions. Vérifier que les types sont correctement utilisés à chaque niveau."
          },
          {
            "id": 5,
            "title": "Refactorer les use cases et la couche présentation",
            "description": "Mettre à jour tous les use cases et widgets pour utiliser la nouvelle entité PlayerGrid",
            "dependencies": [
              "2.4"
            ],
            "details": "1. Identifier tous les use cases qui utilisent DbPlayerGrid et les mettre à jour pour utiliser PlayerGrid. 2. Modifier les providers Riverpod qui exposent des grilles de joueurs. 3. Adapter les widgets UI pour consommer PlayerGrid au lieu de DbPlayerGridModel. 4. Mettre à jour les tests associés aux use cases et widgets. 5. S'assurer que la couche présentation n'a aucune dépendance vers DbPlayerGridModel.",
            "status": "pending",
            "testStrategy": "Tests unitaires pour chaque use case modifié. Tests de widgets pour vérifier que l'UI fonctionne avec la nouvelle entité. Tests d'intégration end-to-end pour valider le flux complet."
          }
        ]
      },
      {
        "id": 3,
        "title": "Création des mappers GameState complets",
        "description": "Implémenter les mappers bidirectionnels complets entre GameState (domain) et GameStateModel (data) pour corriger les problèmes de mapping incomplets",
        "details": "1. Analyser GameState et identifier tous les champs manquants dans GameStateModel. 2. Compléter GameStateModel avec tous les champs nécessaires (currentPlayerIndex, lastAction, etc.). 3. Implémenter toEntity() dans GameStateModel avec gestion complète des sous-objets. 4. Implémenter toModel() comme extension sur GameState. 5. Gérer la conversion des collections (players, actionCards, etc.) avec les mappers appropriés. 6. Ajouter la gestion des cas null et des valeurs par défaut. Code: extension GameStateX on GameState { GameStateModel toModel() => GameStateModel(...); }",
        "testStrategy": "Tests exhaustifs de conversion aller-retour (round-trip) pour vérifier qu'aucune donnée n'est perdue. Tests avec états complexes incluant toutes les cartes actions, multiples joueurs. Tests des cas limites (listes vides, valeurs null).",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyse complète des entités domain et création du modèle de données",
            "description": "Analyser en profondeur les entités GameState, Player, ActionCard et autres pour identifier tous les champs nécessaires dans les modèles data",
            "dependencies": [],
            "details": "1. Examiner GameState dans domain/entities pour lister tous les champs (currentPlayerIndex, lastAction, gamePhase, etc.). 2. Analyser Player, ActionCard, Card et autres entités liées. 3. Créer une matrice de mapping détaillée domain ↔ data. 4. Identifier les champs manquants dans les modèles existants. 5. Documenter les types de données et contraintes pour chaque champ. 6. Définir la stratégie de gestion des valeurs null et optionnelles.",
            "status": "pending",
            "testStrategy": "Créer des tests de vérification de structure pour s'assurer que tous les champs du domain sont représentés dans les modèles. Tests de comparaison des propriétés entre entités et modèles."
          },
          {
            "id": 2,
            "title": "Implémentation complète de GameStateModel avec tous les champs",
            "description": "Enrichir GameStateModel avec tous les champs identifiés et implémenter la sérialisation JSON complète",
            "dependencies": [
              "3.1"
            ],
            "details": "1. Ajouter les champs manquants dans GameStateModel (currentPlayerIndex, lastAction, gamePhase, roundNumber, etc.). 2. Implémenter @JsonSerializable avec les bonnes annotations. 3. Gérer la sérialisation des enums et types complexes. 4. Ajouter les factory constructors fromJson/toJson. 5. Implémenter les valeurs par défaut pour les champs optionnels. 6. Utiliser freezed pour l'immutabilité et la génération de code.",
            "status": "pending",
            "testStrategy": "Tests de sérialisation/désérialisation JSON pour vérifier l'intégrité. Tests avec différentes configurations de données (valeurs null, listes vides, enums). Golden tests pour les structures JSON générées."
          },
          {
            "id": 3,
            "title": "Création des mappers pour les entités associées",
            "description": "Implémenter les mappers bidirectionnels pour Player, ActionCard, Card et autres sous-entités",
            "dependencies": [
              "3.2"
            ],
            "details": "1. Créer PlayerModel.toEntity() et extension PlayerX.toModel(). 2. Implémenter ActionCardModel ↔ ActionCard avec gestion des types spécifiques. 3. Créer les mappers pour Card, DeckState, CardPosition. 4. Gérer la conversion des enums (CardType, ActionType, etc.). 5. Implémenter la logique de conversion des collections imbriquées. 6. Ajouter la validation des données lors du mapping.",
            "status": "pending",
            "testStrategy": "Tests unitaires pour chaque mapper avec vérification de tous les champs. Tests de conversion aller-retour pour garantir aucune perte de données. Tests avec données invalides pour vérifier la robustesse."
          },
          {
            "id": 4,
            "title": "Implémentation de toEntity() et toModel() pour GameState",
            "description": "Créer les méthodes de conversion principales avec gestion complète des relations et collections",
            "dependencies": [
              "3.3"
            ],
            "details": "1. Implémenter GameStateModel.toEntity() avec conversion de tous les champs. 2. Utiliser les mappers des sous-entités pour players.map((p) => p.toEntity()).toList(). 3. Créer extension GameStateX avec toModel() complet. 4. Gérer la conversion des maps et collections complexes. 5. Implémenter la logique de fallback pour les données manquantes. 6. Optimiser les performances avec lazy evaluation si nécessaire.",
            "status": "pending",
            "testStrategy": "Tests exhaustifs de conversion avec états de jeu complexes. Tests de performance avec grandes collections. Tests de cohérence entre conversions successives. Utiliser des fixtures d'états de jeu réels."
          },
          {
            "id": 5,
            "title": "Tests d'intégration et validation des mappers",
            "description": "Créer une suite de tests complète pour valider le système de mapping dans tous les scénarios",
            "dependencies": [
              "3.4"
            ],
            "details": "1. Créer des fixtures d'états de jeu complexes avec toutes les fonctionnalités. 2. Implémenter des tests round-trip pour chaque niveau de mapping. 3. Tester les cas limites (null, listes vides, valeurs maximales). 4. Vérifier la préservation de l'intégrité référentielle. 5. Tester avec des données corrompues ou incomplètes. 6. Créer des benchmarks de performance pour les conversions massives.",
            "status": "pending",
            "testStrategy": "Tests d'intégration end-to-end simulant des parties complètes. Property-based testing pour découvrir des cas non prévus. Tests de régression avec snapshots des structures de données."
          }
        ]
      },
      {
        "id": 4,
        "title": "Configuration du gameStateRepositoryProvider manquant",
        "description": "Créer et configurer le provider Riverpod pour GameStateRepository qui est actuellement manquant, causant des erreurs d'injection de dépendances",
        "details": "1. Créer game_state_repository_provider.dart dans presentation/providers. 2. Définir: final gameStateRepositoryProvider = Provider<GameStateRepository>((ref) => SupabaseGameStateRepository(ref.watch(supabaseGameStateDatasourceProvider))). 3. Créer aussi supabaseGameStateDatasourceProvider si manquant. 4. Vérifier que SupabaseGameStateRepository implémente bien GameStateRepository. 5. Mettre à jour tous les use cases pour utiliser ref.watch(gameStateRepositoryProvider). 6. Suivre le pattern Riverpod 2.x avec annotations @riverpod si applicable.",
        "testStrategy": "Tests d'injection pour vérifier que le provider retourne la bonne instance. Tests d'intégration pour valider que les use cases peuvent accéder au repository. Utiliser ProviderContainer pour les tests isolés.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyser l'architecture existante des providers et datasources",
            "description": "Examiner la structure actuelle des providers Riverpod et identifier les datasources nécessaires pour GameStateRepository",
            "dependencies": [],
            "details": "1. Explorer le dossier lib/features/game/presentation/providers pour comprendre les patterns existants. 2. Vérifier si supabaseGameStateDatasourceProvider existe déjà. 3. Analyser les imports et dépendances de SupabaseGameStateRepository. 4. Identifier tous les use cases qui nécessitent GameStateRepository. 5. Documenter les providers manquants et leurs dépendances.",
            "status": "pending",
            "testStrategy": "Créer des tests de smoke pour vérifier l'existence des fichiers et la cohérence des imports. Utiliser flutter analyze pour détecter les erreurs de dépendances."
          },
          {
            "id": 2,
            "title": "Créer le supabaseGameStateDatasourceProvider",
            "description": "Implémenter le provider pour SupabaseGameStateDatasource qui sera utilisé par gameStateRepositoryProvider",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Créer le fichier game_state_datasource_provider.dart si nécessaire. 2. Définir: final supabaseGameStateDatasourceProvider = Provider<SupabaseGameStateDatasource>((ref) => SupabaseGameStateDatasource(ref.watch(supabaseClientProvider))). 3. Vérifier que supabaseClientProvider existe et est correctement configuré. 4. S'assurer que SupabaseGameStateDatasource a les bonnes dépendances. 5. Ajouter les exports nécessaires dans le barrel file des providers.",
            "status": "pending",
            "testStrategy": "Tests unitaires avec ProviderContainer pour vérifier l'instanciation. Mock du supabaseClient pour les tests isolés. Vérifier que le provider retourne toujours la même instance (singleton)."
          },
          {
            "id": 3,
            "title": "Implémenter le gameStateRepositoryProvider",
            "description": "Créer le provider principal pour GameStateRepository avec injection correcte des dépendances",
            "dependencies": [
              "4.2"
            ],
            "details": "1. Créer game_state_repository_provider.dart dans lib/features/game/presentation/providers. 2. Implémenter: final gameStateRepositoryProvider = Provider<GameStateRepository>((ref) => SupabaseGameStateRepository(ref.watch(supabaseGameStateDatasourceProvider))). 3. Vérifier que SupabaseGameStateRepository implémente correctement l'interface GameStateRepository. 4. Ajouter les annotations @riverpod si le projet utilise Riverpod 2.x avec code generation. 5. Exporter le provider dans le barrel file.",
            "status": "pending",
            "testStrategy": "Tests d'injection avec ProviderContainer pour valider le graphe de dépendances. Tests d'interface pour vérifier que toutes les méthodes de GameStateRepository sont implémentées. Tests de type pour garantir la compatibilité."
          },
          {
            "id": 4,
            "title": "Migrer les use cases vers l'injection par provider",
            "description": "Mettre à jour tous les use cases qui utilisent GameStateRepository pour utiliser le nouveau provider",
            "dependencies": [
              "4.3"
            ],
            "details": "1. Identifier tous les use cases dans lib/features/game/domain/use_cases qui dépendent de GameStateRepository. 2. Créer un provider pour chaque use case: Provider((ref) => UseCase(ref.watch(gameStateRepositoryProvider))). 3. Supprimer les imports directs de datasources ou repositories concrets. 4. Mettre à jour les constructeurs pour accepter l'interface GameStateRepository. 5. Modifier les tests pour utiliser les providers avec ProviderContainer.",
            "status": "pending",
            "testStrategy": "Tests unitaires avec mocks pour chaque use case migré. Vérifier l'absence d'imports de classes concrètes. Tests d'intégration pour valider le flux complet d'injection. Coverage à 100% sur les constructeurs."
          },
          {
            "id": 5,
            "title": "Valider l'intégration complète et nettoyer le code",
            "description": "Effectuer les tests d'intégration finaux et nettoyer les anciens patterns d'injection",
            "dependencies": [
              "4.4"
            ],
            "details": "1. Exécuter flutter analyze pour détecter les erreurs résiduelles. 2. Mettre à jour les widgets qui utilisent les use cases pour utiliser ref.watch. 3. Supprimer les anciennes instanciations directes et les imports inutiles. 4. Vérifier la cohérence avec les autres repositories (ActionCardRepository, etc.). 5. Documenter le nouveau pattern dans un commentaire en tête de fichier. 6. Exécuter tous les tests pour garantir la non-régression.",
            "status": "pending",
            "testStrategy": "Tests end-to-end pour valider le flux complet depuis l'UI. Tests de régression sur l'ensemble de la feature game. Benchmarks de performance pour vérifier l'absence d'overhead. Tests de hot reload pour valider la stabilité."
          }
        ]
      },
      {
        "id": 5,
        "title": "Correction de l'injection des dépendances dans les use cases",
        "description": "Mettre à jour tous les use cases pour utiliser correctement l'injection de dépendances Riverpod au lieu des accès directs aux datasources",
        "details": "1. Identifier tous les use cases qui accèdent directement aux datasources. 2. Modifier chaque use case pour accepter un Repository dans le constructeur. 3. Créer un provider pour chaque use case: final startGameUseCaseProvider = Provider((ref) => StartGameUseCase(ref.watch(gameStateRepositoryProvider))). 4. Supprimer tout import de datasources dans les use cases. 5. Mettre à jour les widgets pour utiliser ref.watch(useCaseProvider). 6. Respecter le principe d'inversion de dépendances (DIP).",
        "testStrategy": "Tests unitaires avec mocks pour chaque use case. Vérifier qu'aucun use case n'importe de datasource. Tests d'intégration pour valider le flux complet depuis le widget. Utiliser Mockito pour les mocks de repositories.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit et inventaire des use cases avec accès direct aux datasources",
            "description": "Identifier et documenter tous les use cases qui violent le principe DIP en accédant directement aux datasources au lieu de passer par les repositories",
            "dependencies": [],
            "details": "Parcourir tous les fichiers dans lib/features/*/domain/use_cases/. Rechercher les imports de datasources (import '../../data/datasources/'). Lister chaque use case problématique avec le datasource utilisé. Identifier les constructeurs qui n'acceptent pas de repository. Documenter les patterns d'accès direct (ref.read, singleton, etc.). Créer une liste de priorité basée sur la criticité.",
            "status": "pending",
            "testStrategy": "Script de vérification grep/ast pour détecter les imports interdits. Tests de régression pour s'assurer qu'aucun nouvel accès direct n'est introduit."
          },
          {
            "id": 2,
            "title": "Refactoring des constructeurs des use cases pour l'injection de repositories",
            "description": "Modifier chaque use case identifié pour accepter un repository via son constructeur au lieu d'accéder directement aux datasources",
            "dependencies": [
              "5.1"
            ],
            "details": "Pour chaque use case: remplacer les accès directs par des paramètres de constructeur. Exemple: class StartGameUseCase { final GameStateRepository _repository; StartGameUseCase(this._repository); }. Supprimer tous les imports de datasources. Remplacer les appels directs par _repository.method(). Assurer que chaque use case ne dépend que des abstractions (interfaces repository). Mettre à jour les signatures des méthodes si nécessaire.",
            "status": "pending",
            "testStrategy": "Tests unitaires avec mocks de repositories pour chaque use case modifié. Vérifier que les use cases n'ont plus d'imports de la couche data/datasources."
          },
          {
            "id": 3,
            "title": "Création des providers Riverpod pour chaque use case",
            "description": "Implémenter un provider dédié pour chaque use case en utilisant l'injection de dépendances avec les repositories providers existants",
            "dependencies": [
              "5.2"
            ],
            "details": "Créer un fichier use_case_providers.dart dans presentation/providers/. Pour chaque use case, définir: final startGameUseCaseProvider = Provider<StartGameUseCase>((ref) => StartGameUseCase(ref.watch(gameStateRepositoryProvider))). Gérer les dépendances multiples si nécessaire. Organiser les providers par feature. Ajouter la documentation sur les dépendances. Exporter tous les providers dans un barrel file.",
            "status": "pending",
            "testStrategy": "Tests avec ProviderContainer pour vérifier l'injection correcte. Tests d'override des providers pour les tests unitaires. Vérifier la résolution des dépendances circulaires."
          },
          {
            "id": 4,
            "title": "Migration des widgets pour utiliser les use case providers",
            "description": "Mettre à jour tous les widgets qui utilisent directement les use cases pour passer par les providers Riverpod",
            "dependencies": [
              "5.3"
            ],
            "details": "Identifier tous les widgets qui créent ou utilisent des use cases. Remplacer les instanciations directes par ref.watch(useCaseProvider). Exemple: final startGame = ref.watch(startGameUseCaseProvider). Gérer les cas avec ConsumerWidget et ConsumerStatefulWidget. Mettre à jour les callbacks et event handlers. Assurer la propagation correcte des erreurs. Optimiser avec ref.read pour les actions ponctuelles.",
            "status": "pending",
            "testStrategy": "Tests de widgets avec mock providers. Vérifier que les widgets ne créent plus d'instances de use cases. Tests d'intégration end-to-end pour valider le flux complet."
          },
          {
            "id": 5,
            "title": "Validation et tests d'intégration de l'architecture DIP",
            "description": "Vérifier que l'architecture respecte complètement le principe d'inversion de dépendances et documenter les patterns",
            "dependencies": [
              "5.4"
            ],
            "details": "Créer des tests d'architecture avec flutter_test ou analyzer. Vérifier qu'aucun use case n'importe de datasource ou modèle. Valider que tous les use cases dépendent uniquement d'abstractions. Tester les scénarios de remplacement de datasources. Documenter les patterns d'injection dans ARCHITECTURE.md. Créer un diagramme de dépendances. Ajouter des lints custom si nécessaire.",
            "status": "pending",
            "testStrategy": "Tests d'architecture automatisés pour détecter les violations DIP. Tests de substitution avec différentes implémentations de repositories. Benchmarks de performance avant/après refactoring."
          }
        ]
      },
      {
        "id": 6,
        "title": "Migration complète des ActionCards vers Supabase",
        "description": "Finaliser la migration du système de cartes actions depuis la mémoire locale vers Supabase avec implémentation complète du datasource et repository",
        "details": "1. Implémenter SupabaseActionCardDataSource avec toutes les méthodes CRUD. 2. Créer ActionCardModel avec json_serializable pour la sérialisation. 3. Implémenter les mappers ActionCard ↔ ActionCardModel. 4. Créer SupabaseActionCardRepository implémentant ActionCardRepository. 5. Migrer les données existantes vers la table action_cards. 6. Implémenter le cache local avec synchronisation. 7. Gérer les conflits de mise à jour avec versioning optimiste. Utiliser Supabase Realtime pour les mises à jour temps réel.",
        "testStrategy": "Tests d'intégration avec base de données de test. Tests de synchronisation avec simulation de latence réseau. Tests de gestion des conflits avec actions concurrentes. Vérifier la cohérence des données après chaque opération.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implémenter SupabaseActionCardDataSource avec méthodes CRUD",
            "description": "Créer le datasource Supabase pour les cartes actions avec toutes les opérations CRUD nécessaires et la gestion des erreurs",
            "dependencies": [],
            "details": "Créer lib/features/game/data/datasources/supabase_action_card_datasource.dart avec les méthodes : getActionCards(), getActionCardById(), createActionCard(), updateActionCard(), deleteActionCard(). Implémenter la gestion des erreurs avec try-catch et conversion des exceptions Supabase. Utiliser le client Supabase injecté via le constructeur. Ajouter les logs pour le debug et le monitoring.",
            "status": "pending",
            "testStrategy": "Tests unitaires avec mock du client Supabase. Tests de chaque méthode CRUD avec différents scénarios de succès et d'échec. Vérifier la conversion correcte des exceptions et les messages d'erreur."
          },
          {
            "id": 2,
            "title": "Créer ActionCardModel avec json_serializable et mappers",
            "description": "Implémenter le modèle de données ActionCardModel avec la sérialisation JSON et les mappers bidirectionnels vers l'entité du domaine",
            "dependencies": [],
            "details": "Créer lib/features/game/data/models/action_card_model.dart avec @JsonSerializable. Définir tous les champs nécessaires : id, name, description, effect, cardType, isRevealed, stock. Implémenter fromJson/toJson avec json_serializable. Créer les méthodes toEntity() et fromEntity() pour la conversion ActionCardModel ↔ ActionCard. Utiliser freezed pour l'immutabilité.",
            "status": "pending",
            "testStrategy": "Tests unitaires de sérialisation/désérialisation JSON. Tests des mappers dans les deux sens. Vérifier la préservation de toutes les propriétés lors des conversions."
          },
          {
            "id": 3,
            "title": "Implémenter SupabaseActionCardRepository",
            "description": "Créer le repository concret qui utilise le datasource et implémente l'interface ActionCardRepository du domaine",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Créer lib/features/game/data/repositories/supabase_action_card_repository.dart. Implémenter toutes les méthodes de l'interface ActionCardRepository. Utiliser le datasource pour les opérations et les mappers pour les conversions. Ajouter la gestion du cache local avec une Map<String, ActionCard>. Implémenter la logique de synchronisation cache/serveur.",
            "status": "pending",
            "testStrategy": "Tests unitaires avec mocks du datasource. Tests du cache local et de la synchronisation. Tests d'intégration avec une base de données de test."
          },
          {
            "id": 4,
            "title": "Configurer Supabase Realtime et gestion des conflits",
            "description": "Implémenter l'écoute des changements en temps réel et la résolution des conflits avec versioning optimiste",
            "dependencies": [
              "6.3"
            ],
            "details": "Ajouter l'abonnement Realtime dans le repository pour écouter les changements de la table action_cards. Implémenter le versioning optimiste avec un champ version dans ActionCardModel. Créer la logique de résolution de conflits : comparer les versions, merger les changements ou notifier l'utilisateur. Gérer la reconnexion automatique en cas de perte de connexion.",
            "status": "pending",
            "testStrategy": "Tests avec simulation de conflits concurrents. Tests de reconnexion après perte réseau. Vérifier la cohérence des données après résolution de conflits."
          },
          {
            "id": 5,
            "title": "Migrer les données existantes et créer le provider Riverpod",
            "description": "Effectuer la migration des données en mémoire vers Supabase et configurer l'injection de dépendances avec Riverpod",
            "dependencies": [
              "6.4"
            ],
            "details": "Créer un script de migration pour transférer les cartes actions existantes vers la table Supabase. Créer actionCardRepositoryProvider dans presentation/providers. Configurer l'injection : Provider<ActionCardRepository>((ref) => SupabaseActionCardRepository(...)). Mettre à jour tous les use cases et widgets pour utiliser le nouveau provider. Ajouter des logs de migration pour tracer le processus.",
            "status": "pending",
            "testStrategy": "Tests de migration avec données de test. Vérifier l'intégrité des données après migration. Tests du provider avec ProviderContainer."
          }
        ]
      },
      {
        "id": 7,
        "title": "Implémentation des fonctions PostgreSQL manquantes",
        "description": "Compléter les fonctions PostgreSQL côté serveur pour gérer l'état complet du jeu incluant les cartes actions et la validation",
        "details": "1. Créer use_action_card(game_id, player_id, card_id, target_data) pour valider et appliquer les effets. 2. Implémenter validate_action_card_usage() pour vérifier les conditions d'utilisation. 3. Créer apply_action_card_effects() avec la logique spécifique par type de carte. 4. Ajouter des triggers pour mettre à jour game_states après utilisation. 5. Implémenter la gestion du stock de 3 cartes maximum par joueur. 6. Ajouter des logs d'audit pour chaque action. Utiliser PL/pgSQL avec gestion des transactions.",
        "testStrategy": "Tests PostgreSQL avec pgTAP. Tests de chaque fonction avec différents scénarios. Tests de performance avec multiples joueurs simultanés. Vérifier l'atomicité des transactions et la cohérence des données.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Création de la fonction use_action_card avec validation des paramètres",
            "description": "Implémenter la fonction principale use_action_card(game_id, player_id, card_id, target_data) qui sera le point d'entrée pour l'utilisation des cartes actions",
            "dependencies": [],
            "details": "Créer la fonction PL/pgSQL avec validation des paramètres d'entrée : vérifier l'existence du game_id, que le player_id appartient bien à la partie, que card_id existe dans le stock du joueur. Retourner un type composite avec success boolean, message text et updated_state jsonb. Gérer les erreurs avec EXCEPTION blocks appropriés.",
            "status": "pending",
            "testStrategy": "Tests pgTAP pour valider les cas d'erreur : game inexistant, joueur non autorisé, carte non possédée. Vérifier que la fonction retourne les bons codes d'erreur et messages."
          },
          {
            "id": 2,
            "title": "Implémentation de validate_action_card_usage pour les règles métier",
            "description": "Créer la fonction de validation qui vérifie toutes les conditions d'utilisation d'une carte action selon son type et l'état du jeu",
            "dependencies": [],
            "details": "Implémenter validate_action_card_usage(game_id, player_id, card_type, target_data) qui vérifie : tour du joueur actif, carte jouable selon l'état (ex: pas de swap sur grille complètement révélée), validité des cibles (positions existantes, joueurs dans la partie). Retourner un record (is_valid boolean, error_message text). Gérer les règles spécifiques par type de carte.",
            "status": "pending",
            "testStrategy": "Tests exhaustifs par type de carte : swap avec positions invalides, peek sur cartes déjà révélées, mirror sur joueur inexistant. Vérifier que chaque règle métier est respectée."
          },
          {
            "id": 3,
            "title": "Développement de apply_action_card_effects avec logique par type",
            "description": "Créer la fonction qui applique les effets spécifiques de chaque type de carte action sur l'état du jeu",
            "dependencies": [
              "7.2"
            ],
            "details": "Implémenter apply_action_card_effects(game_id, player_id, card_type, target_data) avec un CASE statement pour chaque type : SWAP (échanger deux cartes), PEEK (révéler temporairement), MIRROR (copier une carte), etc. Utiliser des fonctions auxiliaires pour chaque effet complexe. Mettre à jour l'état du jeu de manière atomique. Gérer les cartes obligatoires vs optionnelles.",
            "status": "pending",
            "testStrategy": "Tests d'intégration pour chaque effet : vérifier que l'état est correctement modifié, que les historiques sont créés, que les effets en cascade sont appliqués (ex: validation de colonne après swap)."
          },
          {
            "id": 4,
            "title": "Création des triggers et gestion du stock de cartes",
            "description": "Implémenter les triggers PostgreSQL pour maintenir la cohérence après utilisation des cartes et gérer le stock maximum de 3 cartes",
            "dependencies": [
              "7.1",
              "7.3"
            ],
            "details": "Créer trigger after_action_card_used sur game_actions pour : retirer la carte du stock du joueur, vérifier et appliquer la règle des 3 cartes max, mettre à jour game_states.last_action. Implémenter manage_action_card_stock(player_id, game_id) pour forcer la défausse si stock plein. Ajouter trigger pour log automatique dans action_card_logs.",
            "status": "pending",
            "testStrategy": "Tests de concurrence avec multiples utilisations simultanées. Vérifier que le stock ne dépasse jamais 3 cartes. Tester les cas limites : utilisation rapide, ajout pendant défausse forcée."
          },
          {
            "id": 5,
            "title": "Mise en place du système d'audit et optimisation des performances",
            "description": "Implémenter les logs d'audit détaillés et optimiser les performances pour supporter plusieurs parties simultanées",
            "dependencies": [
              "7.1",
              "7.3",
              "7.4"
            ],
            "details": "Créer la table action_card_logs avec colonnes : timestamp, game_id, player_id, card_type, target_data, result, duration_ms. Ajouter des index sur game_actions et game_states pour les requêtes fréquentes. Implémenter log_action_card_usage() appelée automatiquement. Utiliser EXPLAIN ANALYZE pour identifier les goulots. Ajouter pg_stat_statements pour monitoring.",
            "status": "pending",
            "testStrategy": "Tests de charge avec 50+ parties simultanées. Mesurer les temps de réponse < 100ms pour chaque action. Vérifier la complétude des logs avec différents scénarios d'erreur."
          }
        ]
      },
      {
        "id": 8,
        "title": "Réparation des tests unitaires échouants",
        "description": "Corriger les ~100-200 tests qui échouent suite aux changements d'architecture, en adaptant les fixtures et mocks aux nouvelles structures",
        "details": "1. Exécuter flutter test et identifier tous les tests échouants. 2. Grouper les échecs par type (entités, mappers, providers). 3. Mettre à jour les fixtures pour utiliser GamePlayer/LobbyPlayer. 4. Adapter les mocks aux nouvelles interfaces de repositories. 5. Corriger les imports et les chemins suite aux déplacements. 6. Utiliser les builders de test pour créer des objets valides. 7. Vérifier que tous les tests utilisent les bons providers. Prioriser les tests critiques du gameplay.",
        "testStrategy": "Approche itérative: corriger par batch de 10-20 tests. Utiliser --name pour cibler des groupes spécifiques. Vérifier la cohérence des données de test. S'assurer qu'aucun test n'est commenté ou skip.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyse et catégorisation des tests échouants",
            "description": "Exécuter flutter test pour identifier tous les tests en échec et les catégoriser par type et par feature pour prioriser les corrections",
            "dependencies": [],
            "details": "1. Exécuter flutter test > test_report.txt pour capturer tous les échecs. 2. Parser le rapport pour extraire les patterns d'erreur (imports manquants, types incompatibles, mocks obsolètes). 3. Créer un fichier test_analysis.md groupant les échecs par: entités (GameState, Player), repositories, providers, use cases. 4. Identifier les tests critiques du gameplay à corriger en priorité. 5. Estimer le nombre exact de tests à corriger par catégorie. 6. Documenter les patterns de correction récurrents pour automatiser certaines fixes.",
            "status": "pending",
            "testStrategy": "Script d'analyse automatique pour parser les logs de test. Validation manuelle de la catégorisation. Vérifier que tous les tests sont comptabilisés."
          },
          {
            "id": 2,
            "title": "Création des builders et fixtures pour les nouvelles entités",
            "description": "Développer des test builders et fixtures réutilisables pour GamePlayer, LobbyPlayer et les autres entités modifiées dans la nouvelle architecture",
            "dependencies": [
              "8.1"
            ],
            "details": "1. Créer test/helpers/test_builders.dart avec des factory methods pour GamePlayer, LobbyPlayer, GameState. 2. Implémenter des builders avec valeurs par défaut sensées et paramètres optionnels. 3. Créer test/fixtures/ avec des JSON fixtures pour les modèles Supabase. 4. Ajouter des helpers pour générer des listes d'entités (ex: createPlayerList). 5. Documenter l'usage des builders avec exemples. 6. Centraliser la création d'objets de test pour éviter la duplication. Pattern: TestGamePlayer.create(), TestLobbyPlayer.withCustomName().",
            "status": "pending",
            "testStrategy": "Tests unitaires des builders eux-mêmes. Vérifier que les objets créés sont valides selon les contraintes métier. Tests de sérialisation/désérialisation des fixtures JSON."
          },
          {
            "id": 3,
            "title": "Correction des tests des entités et mappers",
            "description": "Réparer tous les tests unitaires des entités domain et des mappers data en utilisant les nouveaux builders et en adaptant aux changements d'architecture",
            "dependencies": [
              "8.2"
            ],
            "details": "1. Corriger game_state_test.dart en utilisant GamePlayer au lieu de Player. 2. Adapter player_grid_test.dart pour la nouvelle structure sans sérialisation. 3. Fixer les tests de mappers DbPlayerGridModel ↔ PlayerGrid. 4. Mettre à jour les tests d'ActionCard avec la nouvelle structure. 5. Corriger les imports cassés suite aux déplacements de fichiers. 6. Remplacer tous les constructeurs manuels par les test builders. 7. Vérifier que copyWith fonctionne correctement avec Freezed. Focus: ~30-40 tests estimés.",
            "status": "pending",
            "testStrategy": "Exécution ciblée avec flutter test test/features/game/domain. Vérification de la couverture sur les entités critiques. Pas de skip ou de tests commentés autorisés."
          },
          {
            "id": 4,
            "title": "Mise à jour des mocks et tests des repositories",
            "description": "Adapter tous les mocks de repositories aux nouvelles interfaces et corriger les tests d'intégration avec les datasources Supabase",
            "dependencies": [
              "8.3"
            ],
            "details": "1. Régénérer les mocks avec mockito pour GameStateRepository, ActionCardRepository. 2. Adapter les when() statements aux nouvelles signatures de méthodes. 3. Corriger supabase_game_state_repository_test.dart avec les bons modèles. 4. Fixer les tests de SupabaseActionCardDataSource (si implémenté). 5. Mettre à jour les tests des use cases utilisant les repositories. 6. Créer des mocks pour les nouveaux providers manquants. 7. Utiliser ProviderContainer pour l'injection dans les tests. Focus: ~40-50 tests estimés.",
            "status": "pending",
            "testStrategy": "Tests d'intégration avec base Supabase de test. Vérification des appels réseau avec dio_mock_adapter. Tests de gestion d'erreurs et edge cases."
          },
          {
            "id": 5,
            "title": "Correction des tests de providers et widgets",
            "description": "Réparer tous les tests des providers Riverpod et des widgets UI en adaptant aux nouveaux providers et à la structure de données modifiée",
            "dependencies": [
              "8.4"
            ],
            "details": "1. Corriger game_state_notifier_test.dart avec le nouveau gameStateRepositoryProvider. 2. Adapter les tests de widgets utilisant ConsumerWidget avec les bons providers. 3. Fixer player_grid_widget_test.dart avec les nouvelles entités. 4. Mettre à jour common_area_widget_test.dart pour les ActionCards. 5. Corriger les tests de navigation avec go_router. 6. Utiliser ProviderScope.overrides pour mocker les providers. 7. Vérifier pumpAndSettle() pour les animations. 8. S'assurer que tous les tests passent sans warnings. Focus: ~50-60 tests.",
            "status": "pending",
            "testStrategy": "Widget tests avec golden tests pour l'UI critique. Tests de providers avec états async. Vérification de l'accessibilité avec semantics. Coverage minimum 80% sur presentation/."
          }
        ]
      },
      {
        "id": 9,
        "title": "Réactivation et migration des tests UI",
        "description": "Réactiver les 3 fichiers de tests UI désactivés (.disabled) et les migrer vers la syntaxe Riverpod 2.x",
        "details": "1. Renommer les fichiers .disabled en .dart. 2. Migrer de Provider.of/Consumer vers ConsumerWidget/ref.watch. 3. Utiliser ProviderScope.overrides pour les tests. 4. Adapter aux nouveaux providers créés (gameStateRepositoryProvider, etc.). 5. Utiliser tester.pumpWidget avec ProviderScope. 6. Gérer l'asynchronicité avec tester.pumpAndSettle(). 7. Vérifier les golden tests si présents. Migration exemple: class MyWidget extends ConsumerWidget { Widget build(BuildContext context, WidgetRef ref) { final gameState = ref.watch(gameStateProvider); }}",
        "testStrategy": "Tests de widgets avec pump et interactions. Vérifier le rendu correct de chaque état. Tests d'intégration pour les flux utilisateur complets. Utiliser flutter_test et mockito pour les dépendances.",
        "priority": "medium",
        "dependencies": [
          4,
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Identification et préparation des fichiers de tests UI désactivés",
            "description": "Localiser les 3 fichiers de tests UI avec extension .disabled et préparer leur réactivation en analysant leur contenu actuel",
            "dependencies": [],
            "details": "1. Scanner le répertoire test/ pour trouver tous les fichiers .disabled. 2. Analyser le contenu de chaque fichier pour identifier les dépendances Provider.of et Consumer. 3. Créer une liste des widgets et providers à migrer. 4. Identifier les golden tests présents. 5. Documenter les imports nécessaires pour Riverpod 2.x. 6. Vérifier les dépendances de test actuelles dans pubspec.yaml",
            "status": "pending",
            "testStrategy": "Vérification manuelle de la présence des fichiers et validation syntaxique après renommage"
          },
          {
            "id": 2,
            "title": "Migration des widgets de StatelessWidget/StatefulWidget vers ConsumerWidget/ConsumerStatefulWidget",
            "description": "Convertir tous les widgets de test utilisant Provider vers la syntaxe Riverpod 2.x avec ConsumerWidget et WidgetRef",
            "dependencies": [
              "9.1"
            ],
            "details": "1. Remplacer extends StatelessWidget par extends ConsumerWidget. 2. Ajouter WidgetRef ref comme paramètre dans build(). 3. Remplacer Provider.of<T>(context) par ref.watch(provider). 4. Migrer Consumer<T> vers ref.watch directement. 5. Adapter les setState() dans StatefulWidget vers ref.read().notifier. 6. Gérer les listen: false avec ref.read(). 7. Mettre à jour les imports avec flutter_riverpod",
            "status": "pending",
            "testStrategy": "Tests de compilation après chaque migration. Vérifier que les widgets se construisent sans erreur"
          },
          {
            "id": 3,
            "title": "Configuration des ProviderScope et overrides pour les tests",
            "description": "Adapter l'infrastructure de test pour utiliser ProviderScope avec les overrides nécessaires pour mocker les dépendances",
            "dependencies": [
              "9.2"
            ],
            "details": "1. Wrapper tous les pumpWidget avec ProviderScope. 2. Créer des mocks pour gameStateRepositoryProvider, actionCardRepositoryProvider. 3. Utiliser overrides: [...] pour injecter les mocks. 4. Configurer les AsyncValue.data() pour les providers asynchrones. 5. Gérer les StateNotifier avec des états initiaux mockés. 6. Créer des helpers de test réutilisables pour les configurations communes",
            "status": "pending",
            "testStrategy": "Tests unitaires pour vérifier que les overrides fonctionnent correctement. Validation des injections de dépendances"
          },
          {
            "id": 4,
            "title": "Gestion de l'asynchronicité et des animations dans les tests",
            "description": "Implémenter la gestion correcte des opérations asynchrones et des animations avec pumpAndSettle et pump",
            "dependencies": [
              "9.3"
            ],
            "details": "1. Remplacer pump() par pumpAndSettle() pour attendre les animations. 2. Utiliser await tester.pump(Duration) pour les timers spécifiques. 3. Gérer les FutureProvider avec await tester.pumpAndSettle(). 4. Implémenter des matchers custom pour les états AsyncValue. 5. Ajouter runAsync pour les opérations futures. 6. Configurer les timeouts appropriés pour les tests longs. 7. Gérer les CircularProgressIndicator pendant le chargement",
            "status": "pending",
            "testStrategy": "Tests avec différents scénarios asynchrones. Vérifier l'absence de timers pendants après les tests"
          },
          {
            "id": 5,
            "title": "Validation des golden tests et finalisation de la migration",
            "description": "Mettre à jour les golden tests si présents et valider que tous les tests UI passent avec la nouvelle architecture",
            "dependencies": [
              "9.4"
            ],
            "details": "1. Identifier les golden tests avec matchesGoldenFile(). 2. Régénérer les goldens avec --update-goldens si nécessaire. 3. Vérifier la compatibilité des goldens avec les nouveaux widgets. 4. Exécuter flutter test sur tous les fichiers migrés. 5. Corriger les erreurs de type et d'assertion. 6. Documenter les changements dans un fichier MIGRATION.md. 7. Mettre à jour le CI/CD pour inclure les tests réactivés",
            "status": "pending",
            "testStrategy": "Exécution complète de la suite de tests. Comparaison visuelle des goldens avant/après migration"
          }
        ]
      },
      {
        "id": 10,
        "title": "Optimisation de la couverture de tests à 80%+",
        "description": "Analyser la couverture actuelle et ajouter les tests manquants pour atteindre le minimum requis de 80%",
        "details": "1. Générer le rapport de couverture: flutter test --coverage. 2. Analyser avec lcov ou coverage pour identifier les gaps. 3. Prioriser les fichiers critiques (use cases, repositories). 4. Écrire des tests pour les branches non couvertes. 5. Ajouter des tests edge cases (erreurs réseau, données invalides). 6. Documenter les tests complexes avec des commentaires. 7. Configurer le CI pour bloquer si < 80%. Utiliser coverage_ignore sparingly pour le code généré uniquement.",
        "testStrategy": "Approche TDD pour les nouveaux tests. Vérifier chaque branche conditionnelle. Tests de régression pour les bugs corrigés. Utiliser des données réalistes dans les tests.",
        "priority": "medium",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Génération et analyse du rapport de couverture initial",
            "description": "Générer le rapport de couverture actuel et analyser les gaps pour identifier les fichiers et branches non couverts",
            "dependencies": [],
            "details": "Exécuter 'flutter test --coverage' pour générer le rapport lcov. Utiliser 'genhtml coverage/lcov.info -o coverage/html' pour visualiser. Analyser avec 'lcov --summary coverage/lcov.info' pour obtenir les statistiques globales. Identifier les fichiers critiques (use cases, repositories, providers) avec une couverture < 80%. Créer une liste priorisée des fichiers à couvrir en se concentrant sur la logique métier du domaine.",
            "status": "pending",
            "testStrategy": "Documenter l'état actuel de la couverture par module (presentation, domain, data). Capturer des screenshots du rapport HTML pour référence. Créer un fichier markdown avec la liste des gaps prioritaires."
          },
          {
            "id": 2,
            "title": "Tests des use cases et logique métier du domaine",
            "description": "Écrire les tests manquants pour tous les use cases du domaine game et multiplayer pour atteindre 100% de couverture",
            "dependencies": [
              "10.1"
            ],
            "details": "Compléter les tests pour DrawCardUseCase, EndTurnUseCase, UseActionCardUseCase avec tous les scénarios edge. Ajouter les tests manquants pour ProcessLastRoundUseCase et CalculateScoresUseCase. Tester les cas d'erreur: repository failures, états invalides, paramètres null. Utiliser des mocks pour les repositories avec mockito. Vérifier chaque branche conditionnelle et les early returns. Implémenter les tests pour les nouvelles fonctionnalités TDD.",
            "status": "pending",
            "testStrategy": "Approche AAA (Arrange, Act, Assert) pour chaque test. Un test par scénario pour maintenir la clarté. Utiliser des fixtures pour les données de test complexes. Grouper les tests par fonctionnalité avec des descriptions claires."
          },
          {
            "id": 3,
            "title": "Tests des repositories et datasources avec mocks Supabase",
            "description": "Implémenter les tests manquants pour les couches data avec simulation complète des interactions Supabase",
            "dependencies": [
              "10.1"
            ],
            "details": "Créer des mocks complets pour SupabaseClient, RealtimeChannel, et PostgrestFilterBuilder. Tester SupabaseGameStateRepository avec tous les scénarios: succès, échecs réseau, timeouts, données invalides. Implémenter les tests pour SupabaseActionCardDatasource et SupabaseRoomDatasource. Vérifier la gestion des erreurs et les retry logic. Tester les transformations de modèles (fromJson/toJson). Simuler les edge cases Realtime: déconnexions, reconnexions, messages dupliqués.",
            "status": "pending",
            "testStrategy": "Utiliser fake_async pour les tests avec delays. Créer des helpers pour générer des réponses Supabase mockées. Tester chaque méthode publique avec au minimum 3 scénarios: succès, échec, edge case."
          },
          {
            "id": 4,
            "title": "Tests des providers Riverpod et gestion d'état",
            "description": "Couvrir tous les providers et notifiers avec des tests d'intégration utilisant ProviderContainer",
            "dependencies": [
              "10.2",
              "10.3"
            ],
            "details": "Tester GameStateNotifier avec tous les événements possibles et transitions d'état. Implémenter les tests pour actionCardProviders avec gestion du cache et invalidation. Tester les providers de repository avec injection de dépendances. Vérifier les auto-dispose providers et leur cycle de vie. Tester les family providers avec différents paramètres. Simuler les race conditions et updates concurrents. Ajouter des tests pour les computed providers et leurs dépendances.",
            "status": "pending",
            "testStrategy": "Utiliser ProviderContainer pour l'isolation des tests. Créer un helper TestProviderScope pour simplifier le setup. Vérifier les rebuilds avec un listener mock. Tester les erreurs avec AsyncError states."
          },
          {
            "id": 5,
            "title": "Configuration CI/CD et maintien de la couverture",
            "description": "Configurer GitHub Actions pour bloquer les PR sous 80% et mettre en place le monitoring continu",
            "dependencies": [
              "10.2",
              "10.3",
              "10.4"
            ],
            "details": "Modifier .github/workflows/flutter.yml pour ajouter l'étape de couverture avec seuil minimum. Utiliser 'very_good_coverage' package pour le check (flutter pub global activate very_good_coverage && very_good_coverage --min-coverage 80). Configurer les badges de couverture dans README.md. Ajouter coverage_ignore judicieusement pour le code généré (*.g.dart, *.freezed.dart). Créer un script pre-commit hook pour vérifier la couverture localement. Documenter les guidelines de test dans CONTRIBUTING.md.",
            "status": "pending",
            "testStrategy": "Tester le workflow CI en créant une PR de test avec couverture insuffisante. Vérifier que le badge se met à jour automatiquement. Valider que les ignores n'affectent que le code généré."
          }
        ]
      },
      {
        "id": 11,
        "title": "Implémentation des animations et transitions UX",
        "description": "Ajouter des animations fluides pour améliorer l'expérience utilisateur lors des interactions de jeu",
        "details": "1. Implémenter AnimationController pour les révélations de cartes avec effet flip 3D. 2. Ajouter Hero animations pour les transitions entre écrans. 3. Utiliser AnimatedContainer pour les changements d'état smooth. 4. Implémenter des animations de glissement pour swap/discard. 5. Ajouter des particules effects pour les actions spéciales (Lottie ou Rive). 6. Optimiser avec AnimatedBuilder pour éviter les rebuilds. 7. Respecter Material Design motion guidelines. Durées: 200-300ms pour les micro-interactions.",
        "testStrategy": "Tests de performance pour vérifier 60 FPS constant. Golden tests pour les états d'animation clés. Tests d'accessibilité avec animations désactivées. Profiler avec Flutter DevTools.",
        "priority": "low",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer l'infrastructure d'animation et les utilitaires de base",
            "description": "Mettre en place les classes de base, les constantes et les utilitaires pour gérer les animations de manière cohérente dans toute l'application",
            "dependencies": [],
            "details": "1. Créer lib/core/animations/animation_constants.dart avec les durées standards (200-300ms pour micro-interactions, 400-600ms pour transitions). 2. Implémenter AnimationUtils avec des courbes prédéfinies (easeInOut, spring, etc.). 3. Créer BaseAnimationWidget abstrait avec AnimationController et lifecycle management. 4. Définir les enums pour les types d'animations (flip, slide, fade, scale). 5. Implémenter AnimationConfig pour permettre aux utilisateurs de désactiver les animations (accessibilité). 6. Créer un ThemeExtension pour stocker les paramètres d'animation.",
            "status": "pending",
            "testStrategy": "Tests unitaires pour vérifier les valeurs des constantes d'animation. Tests de widget pour BaseAnimationWidget avec différentes configurations. Tests d'accessibilité pour vérifier que les animations peuvent être désactivées. Golden tests pour capturer les états d'animation de référence."
          },
          {
            "id": 2,
            "title": "Implémenter l'animation de révélation de carte avec flip 3D",
            "description": "Créer un widget animé pour l'effet de retournement 3D des cartes lors de leur révélation, avec gestion des états et optimisation des performances",
            "dependencies": [
              "11.1"
            ],
            "details": "1. Créer FlipCardAnimationWidget héritant de BaseAnimationWidget. 2. Utiliser Transform avec Matrix4 pour l'effet 3D (rotationY). 3. Implémenter deux faces: CardBackWidget et CardFrontWidget. 4. Gérer l'état isFlipped avec AnimationController et Tween. 5. Ajouter des callbacks onFlipStart et onFlipComplete. 6. Optimiser avec AnimatedBuilder pour éviter les rebuilds inutiles. 7. Implémenter la gestion du toucher pour déclencher l'animation. 8. Ajouter un effet d'ombre dynamique pendant la rotation.",
            "status": "pending",
            "testStrategy": "Tests de widget pour vérifier le comportement du flip dans les deux sens. Tests de performance avec Flutter Driver pour mesurer le FPS (doit rester à 60). Golden tests pour capturer les états intermédiaires de l'animation. Tests d'interaction pour vérifier que le toucher déclenche correctement l'animation."
          },
          {
            "id": 3,
            "title": "Créer les animations de glissement pour swap et discard",
            "description": "Développer des animations fluides pour les actions de glissement des cartes (échange entre joueurs et défausse), avec retour visuel et gestion des gestes",
            "dependencies": [
              "11.1"
            ],
            "details": "1. Créer DraggableCardWidget avec GestureDetector et Transform. 2. Implémenter DragAnimation avec suivi du doigt et physics-based animation. 3. Créer SwapAnimationController pour gérer l'échange visuel entre deux cartes. 4. Implémenter DiscardAnimation avec effet de disparition et trajectoire courbe. 5. Ajouter des indicateurs visuels (zones de drop surbrillance). 6. Gérer les cas d'annulation avec animation de retour élastique. 7. Utiliser Draggable et DragTarget pour la logique de drag & drop. 8. Ajouter haptic feedback sur les actions.",
            "status": "pending",
            "testStrategy": "Tests de gestes avec WidgetTester pour simuler les swipes. Tests de performance pour vérifier la fluidité lors du drag. Tests d'intégration pour valider le comportement complet swap/discard. Tests de régression visuelle avec golden tests pour chaque état de l'animation."
          },
          {
            "id": 4,
            "title": "Intégrer les animations Hero et les transitions entre écrans",
            "description": "Implémenter des transitions fluides entre les différents écrans du jeu en utilisant Hero animations et des transitions personnalisées",
            "dependencies": [
              "11.1"
            ],
            "details": "1. Identifier les éléments à animer entre écrans (avatar joueur, score, cartes). 2. Implémenter Hero widgets avec tags uniques pour chaque élément. 3. Créer PageRouteBuilder personnalisé pour les transitions d'écran. 4. Implémenter FadeTransition et SlideTransition pour les écrans. 5. Ajouter SharedAxisTransition pour la navigation latérale. 6. Créer AnimatedSwitcher pour les changements d'état dans un même écran. 7. Optimiser avec precacheImage pour éviter les saccades. 8. Gérer les cas où Hero animation pourrait causer des problèmes de layout.",
            "status": "pending",
            "testStrategy": "Tests de navigation pour vérifier que les Hero animations se déclenchent. Tests visuels avec golden tests pour capturer les transitions. Tests de performance pour mesurer le temps de transition. Tests d'intégration multi-écrans pour valider le flux complet."
          },
          {
            "id": 5,
            "title": "Ajouter les effets visuels spéciaux et optimiser les performances",
            "description": "Intégrer des effets de particules pour les actions spéciales et optimiser l'ensemble des animations pour maintenir 60 FPS constant",
            "dependencies": [
              "11.2",
              "11.3",
              "11.4"
            ],
            "details": "1. Intégrer Lottie ou Rive pour les animations complexes (victoire, bonus). 2. Créer ParticleEffectWidget pour les effets de confettis et explosions. 3. Implémenter AnimatedContainer pour les changements d'état smooth (couleurs, tailles). 4. Utiliser CustomPainter pour des effets légers (trails, sparkles). 5. Implémenter un AnimationScheduler pour coordonner les animations multiples. 6. Profiler avec Flutter DevTools et optimiser les animations coûteuses. 7. Ajouter RepaintBoundary sur les widgets animés complexes. 8. Implémenter un système de cache pour les animations Lottie/Rive.",
            "status": "pending",
            "testStrategy": "Benchmarks de performance avec Flutter Driver mesurant FPS et frame build time. Tests de charge avec multiples animations simultanées. Memory profiling pour détecter les fuites. Tests A/B comparant les performances avec/sans optimisations."
          }
        ]
      },
      {
        "id": 12,
        "title": "Développement du mode hors-ligne avec synchronisation",
        "description": "Implémenter un système de cache local permettant de jouer sans connexion et synchroniser lors du retour réseau",
        "details": "1. Implémenter un cache local avec Hive ou Drift pour stocker GameState. 2. Créer OfflineActionQueue pour stocker les actions en attente. 3. Implémenter SyncService avec stratégie de résolution de conflits. 4. Utiliser connectivity_plus pour détecter l'état réseau. 5. Implémenter retry logic avec backoff exponentiel. 6. Gérer les conflits avec timestamps et version vectors. 7. Afficher l'état de sync dans l'UI. 8. Limiter le cache à N parties pour éviter l'explosion storage.",
        "testStrategy": "Tests avec NetworkImageMock pour simuler offline. Tests de synchronisation avec états divergents. Tests de résolution de conflits avec actions contradictoires. Vérifier l'intégrité des données après sync.",
        "priority": "low",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configuration de la base de données locale avec Drift",
            "description": "Mettre en place Drift comme solution de persistance locale pour stocker GameState et la file d'actions hors-ligne",
            "dependencies": [],
            "details": "1. Ajouter drift et drift_dev aux dépendances. 2. Créer la base de données locale avec tables: cached_game_states (id, game_id, state_json, version, last_sync, is_dirty), offline_actions_queue (id, game_id, action_type, action_data, timestamp, retry_count, status). 3. Implémenter les DAOs pour CRUD sur ces tables. 4. Créer LocalGameStateEntity et OfflineActionEntity comme entités du domaine. 5. Implémenter les mappers entre entités domaine et modèles Drift. 6. Configurer la migration de schéma et l'initialisation de la DB. 7. Ajouter une limite de stockage (max 10 parties en cache).",
            "status": "pending",
            "testStrategy": "Tests unitaires des DAOs avec base in-memory. Tests d'insertion/récupération de GameState complexes. Tests de la limite de stockage avec rotation FIFO. Tests des migrations de schéma. Vérifier l'intégrité des données JSON stockées."
          },
          {
            "id": 2,
            "title": "Implémentation du repository hybride local/remote",
            "description": "Créer un HybridGameStateRepository qui gère automatiquement le basculement entre cache local et API Supabase selon la connectivité",
            "dependencies": [
              "12.1"
            ],
            "details": "1. Créer HybridGameStateRepository implémentant GameStateRepository. 2. Injecter LocalGameStateRepository (Drift) et SupabaseGameStateRepository. 3. Implémenter la logique de décision: si online, tenter Supabase d'abord puis fallback sur local; si offline, utiliser local uniquement. 4. Implémenter saveGameState() qui sauvegarde localement ET marque comme 'dirty' si offline. 5. Implémenter getGameState() avec merge strategy si divergence. 6. Créer OfflineActionQueueRepository pour gérer la file d'actions. 7. Ajouter connectivity_plus pour détecter l'état réseau. 8. Implémenter un provider Riverpod pour ce repository hybride.",
            "status": "pending",
            "testStrategy": "Tests avec mock de connectivity pour simuler online/offline. Tests du fallback automatique lors d'échec réseau. Tests de sauvegarde avec flag dirty. Tests de récupération avec stratégie de merge. Vérifier la cohérence des données entre local et remote."
          },
          {
            "id": 3,
            "title": "Développement du service de synchronisation avec résolution de conflits",
            "description": "Créer SyncService pour synchroniser les données locales avec Supabase lors du retour en ligne, avec gestion intelligente des conflits",
            "dependencies": [
              "12.2"
            ],
            "details": "1. Créer SyncService avec méthode syncPendingChanges(). 2. Implémenter la détection de retour en ligne via connectivity_plus stream. 3. Récupérer tous les GameState marqués dirty et actions en queue. 4. Implémenter version vectors pour détecter les conflits (local_version, remote_version). 5. Stratégie de résolution: pour les actions de jeu, appliquer dans l'ordre chronologique; pour les conflits d'état, privilégier la version avec le plus d'actions. 6. Implémenter retry logic avec backoff exponentiel (2^n secondes, max 5 tentatives). 7. Gérer les erreurs partielles et rollback si nécessaire. 8. Notifier l'UI des progrès de sync via Stream.",
            "status": "pending",
            "testStrategy": "Tests de synchronisation avec états divergents simulés. Tests de résolution avec actions contradictoires (ex: même carte jouée par 2 joueurs). Tests du retry avec échecs simulés. Tests de rollback en cas d'erreur critique. Vérifier l'ordre chronologique des actions."
          },
          {
            "id": 4,
            "title": "Création de l'interface utilisateur pour l'état hors-ligne",
            "description": "Développer les widgets et indicateurs visuels pour informer l'utilisateur de l'état de connexion et de synchronisation",
            "dependencies": [
              "12.3"
            ],
            "details": "1. Créer ConnectivityIndicatorWidget affichant l'état réseau (online/offline) avec icône appropriée. 2. Créer SyncStatusWidget montrant: nombre d'actions en attente, progression de sync, dernière sync réussie. 3. Implémenter des providers Riverpod pour l'état de connectivité et sync. 4. Ajouter bannière 'Mode hors-ligne' en haut de l'écran de jeu si offline. 5. Afficher badge sur les actions en attente de sync. 6. Implémenter SnackBar pour notifier la fin de synchronisation. 7. Ajouter animation de chargement pendant la sync. 8. Gérer l'affichage des erreurs de sync avec option de retry manuel.",
            "status": "pending",
            "testStrategy": "Tests de widgets avec différents états de connectivité. Tests d'affichage avec 0, 5, 50 actions en attente. Tests des animations et transitions d'état. Tests d'accessibilité des indicateurs. Vérifier la réactivité aux changements d'état."
          },
          {
            "id": 5,
            "title": "Tests d'intégration et optimisation des performances",
            "description": "Implémenter une suite complète de tests d'intégration pour le mode hors-ligne et optimiser les performances de synchronisation",
            "dependencies": [
              "12.4"
            ],
            "details": "1. Créer NetworkSimulator pour tests contrôlés online/offline. 2. Tests end-to-end: jouer 10 coups offline, reconnecter, vérifier sync complète. 3. Tests de stress: 100+ actions en queue, mesurer temps de sync. 4. Implémenter batch sync pour grouper les actions (max 20 par requête). 5. Optimiser la sérialisation JSON avec compression si >1KB. 6. Ajouter cache mémoire pour GameState fréquemment accédés. 7. Implémenter throttling pour éviter spam de sync. 8. Profiler et optimiser les requêtes Drift. 9. Documenter les limites du mode offline (max 7 jours, max 1000 actions).",
            "status": "pending",
            "testStrategy": "Tests de performance avec grands volumes de données. Tests de robustesse avec coupures réseau aléatoires. Tests de cohérence après multiples cycles offline/online. Benchmarks de temps de sync. Tests de consommation mémoire et batterie en mode offline prolongé."
          }
        ]
      },
      {
        "id": 13,
        "title": "Configuration de l'environnement de production",
        "description": "Préparer l'application pour le déploiement en production avec les bonnes configurations et optimisations",
        "details": "1. Configurer les flavors Flutter (dev, staging, prod) avec configurations séparées. 2. Implémenter la gestion des secrets avec --dart-define-from-file. 3. Optimiser les assets avec flutter_native_splash et flutter_launcher_icons. 4. Configurer ProGuard/R8 pour l'obfuscation Android. 5. Implémenter App Bundle avec dynamic delivery. 6. Ajouter les métadonnées Play Store (descriptions, screenshots). 7. Créer privacy policy et terms of service. 8. Configurer les deep links et app links. Version: semantic versioning avec build number auto-incrémenté.",
        "testStrategy": "Tests de build pour chaque flavor. Vérifier les tailles d'APK/AAB. Tests de performance sur devices réels. Audit de sécurité avec MobSF. Tests des deep links sur différentes versions Android.",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configuration des flavors Flutter et gestion des secrets",
            "description": "Mettre en place les flavors dev, staging et prod avec leurs configurations spécifiques et implémenter la gestion sécurisée des secrets",
            "dependencies": [],
            "details": "1. Créer les fichiers de configuration pour chaque flavor dans android/app/src/{dev,staging,prod}. 2. Configurer build.gradle avec productFlavors et leurs applicationIdSuffix. 3. Créer les fichiers .env.dev, .env.staging, .env.prod avec les variables d'environnement. 4. Implémenter un script Dart pour générer les fichiers --dart-define-from-file. 5. Configurer les différentes URLs Supabase et clés API par environnement. 6. Ajouter les fichiers secrets au .gitignore. 7. Documenter le processus de build par flavor.",
            "status": "pending",
            "testStrategy": "Vérifier que chaque flavor build correctement avec flutter build apk --flavor dev. Tester que les bonnes variables d'environnement sont chargées. Valider que les secrets ne sont pas exposés dans le code compilé."
          },
          {
            "id": 2,
            "title": "Optimisation des assets et configuration des icônes",
            "description": "Configurer flutter_native_splash et flutter_launcher_icons pour optimiser l'expérience de lancement et l'identité visuelle de l'app",
            "dependencies": [],
            "details": "1. Installer et configurer flutter_native_splash dans pubspec.yaml. 2. Créer les assets du splash screen en différentes résolutions. 3. Configurer les couleurs et animations du splash par flavor. 4. Installer flutter_launcher_icons et créer les icônes adaptatives. 5. Générer les icônes pour chaque densité Android. 6. Optimiser tous les assets images avec des outils de compression. 7. Configurer les assets conditionnels par flavor si nécessaire.",
            "status": "pending",
            "testStrategy": "Vérifier la génération correcte des icônes pour toutes les densités. Tester le splash screen sur différentes tailles d'écran. Mesurer le temps de lancement de l'app. Valider la taille finale des assets."
          },
          {
            "id": 3,
            "title": "Configuration de l'obfuscation et optimisation du build",
            "description": "Mettre en place ProGuard/R8 pour l'obfuscation du code et optimiser la taille de l'APK/AAB",
            "dependencies": [
              "13.1"
            ],
            "details": "1. Créer android/app/proguard-rules.pro avec les règles de base Flutter. 2. Ajouter les règles keep pour Supabase, Riverpod et autres dépendances. 3. Configurer minifyEnabled et shrinkResources dans build.gradle. 4. Tester l'obfuscation avec des builds release. 5. Implémenter le split APK par ABI pour réduire la taille. 6. Configurer l'App Bundle avec modules dynamiques si pertinent. 7. Analyser la taille finale avec bundletool.",
            "status": "pending",
            "testStrategy": "Builder en release et vérifier que l'app fonctionne correctement. Analyser les crashs potentiels dus à l'obfuscation. Comparer les tailles avant/après optimisation. Tester sur différentes architectures ARM."
          },
          {
            "id": 4,
            "title": "Préparation des métadonnées Play Store et aspects légaux",
            "description": "Créer tous les éléments nécessaires pour la publication sur le Play Store incluant les descriptions, screenshots et documents légaux",
            "dependencies": [
              "13.2"
            ],
            "details": "1. Rédiger les descriptions courte et longue en français pour le Play Store. 2. Créer les screenshots de l'app dans les dimensions requises (phone, tablet). 3. Générer une vidéo de présentation du gameplay. 4. Rédiger la politique de confidentialité conforme RGPD. 5. Créer les conditions d'utilisation adaptées au jeu. 6. Préparer le formulaire de classification du contenu. 7. Créer les graphiques promotionnels (feature graphic, banner).",
            "status": "pending",
            "testStrategy": "Valider les textes avec un correcteur orthographique. Vérifier les dimensions des images avec les guidelines Google. Faire relire les documents légaux. Tester l'affichage des screenshots sur différents appareils."
          },
          {
            "id": 5,
            "title": "Configuration des deep links et versioning automatique",
            "description": "Implémenter les deep links pour l'app et mettre en place un système de versioning sémantique avec build number auto-incrémenté",
            "dependencies": [
              "13.3"
            ],
            "details": "1. Configurer les intent-filters Android pour les deep links ojyx://. 2. Implémenter la gestion des routes deep link avec go_router. 3. Configurer les app links vérifiés avec assetlinks.json. 4. Créer un script de versioning automatique qui incrémente le build number. 5. Intégrer le versioning dans le pipeline CI/CD. 6. Ajouter les métadonnées de version dans l'app. 7. Tester les liens pour rejoindre une partie directement.",
            "status": "pending",
            "testStrategy": "Tester les deep links avec adb shell am start. Vérifier la navigation correcte depuis un lien externe. Valider l'incrémentation automatique du build number. Tester les app links sur un domaine de test."
          }
        ]
      },
      {
        "id": 14,
        "title": "Mise en place du pipeline CI/CD de production",
        "description": "Configurer un pipeline complet pour automatiser les builds, tests et déploiements vers le Play Store",
        "details": "1. Étendre .github/workflows pour inclure les builds release. 2. Configurer Fastlane pour l'automatisation Play Store. 3. Implémenter semantic-release pour le versioning automatique. 4. Ajouter les étapes: lint → test → build → upload. 5. Configurer les secrets GitHub pour les clés de signature. 6. Implémenter les release notes automatiques depuis les commits. 7. Ajouter des notifications Slack/Discord pour les déploiements. 8. Configurer les tracks Play Store (internal, alpha, beta, production). Utiliser GitHub Environments pour les approbations.",
        "testStrategy": "Tests du pipeline sur une branche dédiée. Dry-run des déploiements Play Store. Vérifier les signatures APK. Tests de rollback en cas d'échec. Monitoring des métriques de build time.",
        "priority": "medium",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configuration de Fastlane pour l'automatisation Android",
            "description": "Installer et configurer Fastlane avec les lanes nécessaires pour automatiser les builds et déploiements Android vers le Play Store",
            "dependencies": [],
            "details": "1. Installer Fastlane via bundler (créer Gemfile avec fastlane). 2. Exécuter 'fastlane init' et sélectionner Android. 3. Configurer le fichier Appfile avec package_name et json_key_file. 4. Créer les lanes dans Fastfile: test_lane (flutter test), build_lane (flutter build appbundle), deploy_internal (upload_to_play_store track: 'internal'), deploy_alpha, deploy_beta, deploy_production. 5. Configurer supply pour le Play Store avec 'fastlane supply init'. 6. Créer le fichier .env.default pour les variables d'environnement. 7. Tester localement avec 'fastlane test_lane'.",
            "status": "pending",
            "testStrategy": "Exécuter chaque lane en mode dry-run. Vérifier la génération correcte des AAB. Tester avec un compte Play Console de test. Valider les métadonnées générées par supply."
          },
          {
            "id": 2,
            "title": "Mise en place de semantic-release et gestion du versioning",
            "description": "Configurer semantic-release pour automatiser le versioning basé sur les commits conventionnels et générer les changelogs",
            "dependencies": [],
            "details": "1. Installer semantic-release et plugins: @semantic-release/changelog, @semantic-release/git, @semantic-release/github, @semantic-release/exec. 2. Créer .releaserc.json avec configuration des branches (main, beta, alpha). 3. Configurer les plugins pour: analyser les commits (conventional-commits), générer CHANGELOG.md, mettre à jour pubspec.yaml avec la nouvelle version via @semantic-release/exec, créer le tag git et release GitHub. 4. Créer script update-flutter-version.js pour modifier pubspec.yaml. 5. Configurer les règles de versioning: feat → minor, fix → patch, breaking → major. 6. Ajouter les commit hooks avec husky pour forcer conventional commits.",
            "status": "pending",
            "testStrategy": "Simuler des releases avec différents types de commits. Vérifier la génération correcte du CHANGELOG. Valider que pubspec.yaml est mis à jour. Tester les releases sur une branche dédiée."
          },
          {
            "id": 3,
            "title": "Extension du workflow GitHub Actions pour les builds release",
            "description": "Modifier le workflow CI/CD existant pour inclure les étapes de build release, signature et upload vers Play Store",
            "dependencies": [
              "14.1",
              "14.2"
            ],
            "details": "1. Créer release.yml dans .github/workflows déclenché sur push tags 'v*'. 2. Définir les jobs: lint (dart format --set-exit-if-changed), test (flutter test --coverage), build (flutter build appbundle --release). 3. Configurer les secrets GitHub: PLAY_STORE_UPLOAD_KEY (base64 du keystore), KEY_STORE_PASSWORD, KEY_PASSWORD, ALIAS, PLAY_STORE_CONFIG_JSON (compte de service). 4. Ajouter étape de décodage et configuration du keystore. 5. Intégrer semantic-release pour déterminer la version. 6. Utiliser Fastlane via 'bundle exec fastlane deploy_$TRACK'. 7. Implémenter la matrice de déploiement selon les branches.",
            "status": "pending",
            "testStrategy": "Tester sur une branche feature avec dry-run. Vérifier la signature correcte de l'APK/AAB. Valider les artifacts générés. Tester le workflow complet sur un fork."
          },
          {
            "id": 4,
            "title": "Configuration des environnements GitHub et tracks Play Store",
            "description": "Mettre en place les GitHub Environments avec approbations manuelles et configurer les tracks Play Store pour le déploiement progressif",
            "dependencies": [
              "14.3"
            ],
            "details": "1. Créer les environnements GitHub: development, staging, production avec protection rules. 2. Configurer les approbations requises: staging (1 reviewer), production (2 reviewers + admin). 3. Définir les secrets spécifiques par environnement. 4. Dans Play Console: créer les tracks internal (équipe QA), alpha (testeurs internes), beta (testeurs externes), production. 5. Configurer les critères de promotion: internal → alpha (tests automatisés passés), alpha → beta (approbation manuelle), beta → production (métriques de stabilité OK). 6. Implémenter les règles de rollout progressif: 10% → 50% → 100%. 7. Ajouter les conditions dans le workflow pour déployer selon l'environnement.",
            "status": "pending",
            "testStrategy": "Simuler les déploiements sur chaque environnement. Tester les approbations manuelles. Vérifier les rollbacks. Valider les métriques de crash-free rate."
          },
          {
            "id": 5,
            "title": "Implémentation des notifications et monitoring du pipeline",
            "description": "Ajouter les notifications Slack/Discord pour les événements du pipeline et mettre en place le monitoring des métriques de build",
            "dependencies": [
              "14.3",
              "14.4"
            ],
            "details": "1. Créer un webhook Slack/Discord pour les notifications CI/CD. 2. Utiliser l'action slack-notify ou discord-webhook pour envoyer: début de build, succès/échec avec détails, lien vers les artifacts, changelog de la release. 3. Configurer les notifications différenciées par environnement (couleurs, mentions). 4. Implémenter le monitoring: durée des builds, taux de succès, taille des artifacts. 5. Créer un dashboard GitHub Actions avec badges de statut. 6. Ajouter les métriques dans Sentry: releases, source maps, commits associés. 7. Configurer les alertes pour: builds échoués consécutifs, augmentation du temps de build, diminution du coverage.",
            "status": "pending",
            "testStrategy": "Tester chaque type de notification. Vérifier la réception sur Slack/Discord. Simuler des échecs pour valider les alertes. Mesurer les métriques sur plusieurs builds."
          }
        ]
      },
      {
        "id": 15,
        "title": "Configuration du monitoring et analytics production",
        "description": "Implémenter un système complet de monitoring pour suivre la santé de l'application en production",
        "details": "1. Configurer Sentry avec les bons environnements et release tracking. 2. Implémenter Firebase Analytics pour les événements utilisateur. 3. Ajouter Firebase Crashlytics comme backup de Sentry. 4. Configurer des dashboards personnalisés (temps de jeu, actions populaires). 5. Implémenter performance monitoring avec traces custom. 6. Ajouter des health checks pour Supabase. 7. Configurer des alertes pour les erreurs critiques. 8. Implémenter A/B testing avec Firebase Remote Config. GDPR: demander consentement avant tracking.",
        "testStrategy": "Tests d'envoi d'événements en environnement de test. Vérifier la désactivation du tracking en dev. Tests GDPR compliance. Simulation de crashes pour valider les rapports. Tests de performance des SDK analytics.",
        "priority": "low",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configuration de Sentry pour le monitoring des erreurs",
            "description": "Mettre en place Sentry avec environnements séparés, release tracking et gestion GDPR compliant",
            "dependencies": [],
            "details": "1. Installer le package sentry_flutter et configurer SentryFlutter.init dans main.dart. 2. Créer SentryConfig dans core/config avec gestion des environnements (dev, staging, prod). 3. Implémenter le release tracking avec version automatique depuis pubspec.yaml. 4. Configurer beforeSend pour filtrer les données sensibles. 5. Ajouter un ConsentManager pour demander l'autorisation utilisateur avant d'activer Sentry (GDPR). 6. Créer des wrappers pour capturer les erreurs métier spécifiques (GameError, NetworkError). 7. Configurer les tags et contextes (userId anonyme, gameRoom, etc.).",
            "status": "pending",
            "testStrategy": "Tests unitaires pour vérifier la configuration conditionnelle par environnement. Tests du ConsentManager avec mock SharedPreferences. Tests d'intégration pour valider l'envoi d'événements en environnement test. Vérifier que Sentry est désactivé sans consentement."
          },
          {
            "id": 2,
            "title": "Intégration de Firebase Analytics et Crashlytics",
            "description": "Configurer Firebase pour le tracking des événements utilisateur et comme système de crash reporting de secours",
            "dependencies": [
              "15.1"
            ],
            "details": "1. Ajouter firebase_core, firebase_analytics et firebase_crashlytics aux dépendances. 2. Configurer Firebase pour Android avec google-services.json par flavor. 3. Créer AnalyticsService dans core/services avec méthodes pour logger les événements de jeu (game_started, card_played, action_used). 4. Implémenter FirebaseCrashlyticsConfig comme backup de Sentry avec la même logique de consentement. 5. Créer des événements analytics typés avec paramètres (GameEvent, UserEvent). 6. Configurer la collection automatique des propriétés utilisateur anonymisées. 7. Implémenter le debug view pour les tests.",
            "status": "pending",
            "testStrategy": "Tests avec Firebase Test Lab pour valider les événements. Mock de FirebaseAnalytics pour tests unitaires. Tests du système de consentement unifié Sentry/Firebase. Vérification que les événements ne contiennent pas de données personnelles."
          },
          {
            "id": 3,
            "title": "Implémentation du Performance Monitoring avec traces custom",
            "description": "Mettre en place le monitoring de performance pour identifier les goulots d'étranglement dans le gameplay",
            "dependencies": [
              "15.2"
            ],
            "details": "1. Ajouter firebase_performance au projet et configurer l'auto-collection. 2. Créer PerformanceTracker dans core/services avec méthodes pour démarrer/arrêter des traces. 3. Implémenter des traces custom pour: synchronisation Supabase, rendu des grilles de cartes, calcul des scores, animations complexes. 4. Ajouter des métriques custom (nombre de cartes, taille des données sync). 5. Créer un décorateur @Traced pour annoter les méthodes critiques. 6. Configurer des seuils d'alerte pour les opérations lentes (>2s pour sync, >500ms pour UI). 7. Implémenter le sampling pour réduire l'overhead en production.",
            "status": "pending",
            "testStrategy": "Tests de performance avec profiling pour mesurer l'overhead du monitoring. Tests des traces avec Timer mock. Validation que le monitoring n'impacte pas le gameplay. Tests du sampling avec différents taux."
          },
          {
            "id": 4,
            "title": "Création des health checks et monitoring Supabase",
            "description": "Développer un système de surveillance de la santé de la connexion Supabase et des services critiques",
            "dependencies": [
              "15.3"
            ],
            "details": "1. Créer HealthCheckService avec vérifications périodiques de Supabase (auth, realtime, database). 2. Implémenter un endpoint de health check côté Supabase avec fonction Edge. 3. Ajouter des métriques de latence pour chaque type d'opération (query, mutation, subscription). 4. Créer un ConnectionMonitor qui track les déconnexions/reconnexions WebSocket. 5. Implémenter un système de retry intelligent avec backoff exponentiel. 6. Logger les métriques dans Firebase Analytics (connection_lost, reconnection_time). 7. Ajouter une UI minimale pour afficher l'état de connexion aux joueurs.",
            "status": "pending",
            "testStrategy": "Tests avec simulation de coupures réseau. Tests du circuit breaker avec Supabase mock. Validation des métriques de latence avec différentes conditions réseau. Tests du retry avec différents scénarios d'échec."
          },
          {
            "id": 5,
            "title": "Configuration des dashboards et alertes de monitoring",
            "description": "Créer des tableaux de bord personnalisés et configurer les alertes pour les incidents critiques",
            "dependencies": [
              "15.4"
            ],
            "details": "1. Configurer les dashboards Firebase Console pour visualiser: temps de jeu moyen, actions les plus utilisées, taux de complétion des parties. 2. Créer des segments d'utilisateurs (nouveaux, actifs, churned) dans Analytics. 3. Configurer les alertes Sentry pour: erreurs critiques (>10/min), nouvelles erreurs, regression après release. 4. Implémenter Firebase Remote Config pour A/B testing des features. 5. Créer des alertes custom pour: serveur Supabase down, taux d'erreur WebSocket élevé, performance dégradée. 6. Configurer l'intégration Slack/Discord pour les notifications. 7. Documenter les runbooks pour chaque type d'alerte.",
            "status": "pending",
            "testStrategy": "Tests des webhooks d'alerte avec payloads simulés. Validation des seuils d'alerte avec données de test. Tests A/B avec Remote Config en environnement staging. Simulation d'incidents pour valider les runbooks."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-25T08:09:44.471Z",
      "updated": "2025-07-25T08:09:44.471Z",
      "description": "Tasks for master context"
    }
  }
}