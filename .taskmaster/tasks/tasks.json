{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Exécution de la Grande Purge des Fichiers",
        "description": "Identifier et supprimer massivement tous les fichiers inutiles incluant documentation obsolète, scripts de test, configurations CI/CD, logs et autres artefacts qui ralentissent le développement",
        "details": "1. Analyser l'arborescence complète du projet avec 'find' ou 'ls -la' récursif\n2. Identifier les patterns de fichiers à supprimer :\n   - Tous les fichiers *.test.dart, *_test.dart\n   - Répertoire complet /test et /integration_test\n   - Scripts dans /scripts sauf ceux absolument essentiels\n   - Fichiers .github/workflows/* sauf le strict minimum\n   - Documentation technique complexe (*.md) sauf README.md et CLAUDE.md\n   - Fichiers de configuration de test (test_driver/, coverage/, .lcov)\n3. Créer un script de purge ou utiliser des commandes bash directes\n4. Exécuter la suppression avec confirmation\n5. Valider que le projet reste fonctionnel après purge\n6. Commit avec message clair 'chore: purge massive des fichiers superflus'",
        "testStrategy": "Validation manuelle post-purge : vérifier que 'flutter pub get' et 'flutter analyze' passent sans erreur. S'assurer que le projet compile toujours.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyse complète de l'arborescence du projet",
            "description": "Scanner récursivement tous les répertoires et fichiers du projet pour créer un inventaire détaillé des éléments à purger",
            "dependencies": [],
            "details": "Utiliser 'find . -type f -name \"*.dart\" | grep -E \"(_test\\.dart|test\\.dart)$\"' pour lister tous les fichiers de test. Utiliser 'ls -la' récursif ou 'tree' pour visualiser la structure complète. Créer une liste exhaustive dans un fichier temporaire 'files_to_delete.txt' avec tous les chemins des fichiers identifiés pour suppression. Inclure : /test/*, /integration_test/*, /scripts/* (sauf essentiels), /.github/workflows/* (sauf ci.yml minimal), tous les *.md sauf README.md et CLAUDE.md, /test_driver/*, /coverage/*, *.lcov",
            "status": "done",
            "testStrategy": "Vérifier que le fichier files_to_delete.txt contient au moins 50% des fichiers actuels du projet. S'assurer qu'aucun fichier source principal (/lib/*) n'est dans la liste"
          },
          {
            "id": 2,
            "title": "Suppression des répertoires de test complets",
            "description": "Supprimer entièrement les répertoires /test et /integration_test qui contiennent tous les tests unitaires et d'intégration",
            "dependencies": [
              "1.1"
            ],
            "details": "Exécuter 'rm -rf test/' pour supprimer le répertoire de tests unitaires. Exécuter 'rm -rf integration_test/' pour supprimer les tests d'intégration. Vérifier aussi la présence de 'test_driver/' et le supprimer si présent avec 'rm -rf test_driver/'. Supprimer également tout répertoire 'coverage/' avec 'rm -rf coverage/'. Ces suppressions doivent être faites en une seule commande pour éviter les confirmations : 'rm -rf test/ integration_test/ test_driver/ coverage/'",
            "status": "done",
            "testStrategy": "Vérifier avec 'ls -la' que les répertoires /test, /integration_test, /test_driver et /coverage n'existent plus. Confirmer qu'aucun fichier *_test.dart ne reste dans le projet avec 'find . -name \"*_test.dart\"'"
          },
          {
            "id": 3,
            "title": "Purge des scripts et configurations CI/CD",
            "description": "Nettoyer le répertoire /scripts en gardant uniquement les scripts essentiels et supprimer les workflows GitHub Actions superflus",
            "dependencies": [
              "1.1"
            ],
            "details": "Dans /scripts/, identifier et garder UNIQUEMENT : clean_build.sh (si nécessaire pour le build). Supprimer tous les autres scripts notamment : install-hooks.sh, test-hooks.sh, validate_*.sh, pre-commit-hook.sh, commit-msg-hook.sh. Pour .github/workflows/, supprimer TOUS les fichiers sauf un ci.yml minimal si absolument nécessaire. Commandes : 'cd scripts && ls -la' puis 'rm -f install-hooks.sh test-hooks.sh validate_*.sh *-hook.sh'. Pour workflows : 'rm -f .github/workflows/release.yml .github/dependabot.yml'",
            "status": "done",
            "testStrategy": "Vérifier que /scripts ne contient plus que 1-2 fichiers maximum. Vérifier que .github/workflows/ est vide ou ne contient qu'un seul fichier minimal"
          },
          {
            "id": 4,
            "title": "Suppression des fichiers de test individuels et documentation technique",
            "description": "Rechercher et supprimer tous les fichiers *_test.dart restants dans /lib et supprimer la documentation technique non essentielle",
            "dependencies": [
              "1.2",
              "1.3"
            ],
            "details": "Utiliser 'find . -name \"*_test.dart\" -o -name \"*.test.dart\" | grep -v node_modules | xargs rm -f' pour supprimer tous les fichiers de test restants. Pour la documentation, lister tous les *.md avec 'find . -name \"*.md\"' et supprimer tout sauf README.md et CLAUDE.md. Supprimer spécifiquement : CONTRIBUTING.md, CHANGELOG.md, CODE_OF_CONDUCT.md, SECURITY.md, docs/*.md. Supprimer aussi tous les fichiers .lcov et de coverage : 'find . -name \"*.lcov\" -delete'. Nettoyer aussi les fichiers de configuration de test comme .test_config, darttest.yaml",
            "status": "done",
            "testStrategy": "Exécuter 'find . -name \"*test*\" -type f' et vérifier qu'aucun fichier de test ne reste. Vérifier que seuls README.md et CLAUDE.md existent comme fichiers markdown"
          },
          {
            "id": 5,
            "title": "Validation finale et commit de la purge",
            "description": "Vérifier que le projet reste fonctionnel après la purge massive et committer tous les changements",
            "dependencies": [
              "1.4"
            ],
            "details": "Exécuter 'flutter clean' puis 'flutter pub get' pour réinitialiser les dépendances. Vérifier avec 'flutter analyze --no-fatal-infos' que le code compile toujours. Tester un build rapide avec 'flutter build apk --debug' pour confirmer la compilation. Faire un 'git status' pour voir tous les fichiers supprimés. Utiliser 'git add -A' pour stager toutes les suppressions. Committer avec exactement ce message : 'chore: purge massive des fichiers superflus - suppression tests, CI/CD, docs'. Optionnel : créer un tag 'pre-purge' avant le commit pour pouvoir revenir en arrière si nécessaire",
            "status": "done",
            "testStrategy": "Le projet doit compiler sans erreur avec 'flutter build apk --debug'. 'flutter analyze' ne doit montrer aucune erreur liée aux suppressions. Le commit doit montrer au moins 100+ fichiers supprimés"
          }
        ]
      },
      {
        "id": 2,
        "title": "Suppression Complète des Tests et Infrastructure TDD",
        "description": "Éliminer totalement le répertoire /test et toute trace de l'infrastructure TDD précédente pour repartir sur une base vierge",
        "details": "1. Supprimer complètement le répertoire /test avec 'rm -rf test/'\n2. Supprimer /integration_test si présent\n3. Nettoyer pubspec.yaml :\n   - Retirer les dépendances de test (test:, mockito:, etc.) de dev_dependencies\n   - Garder uniquement flutter_test si nécessaire pour tests futurs\n4. Supprimer les imports de test dans tout le code\n5. Rechercher et supprimer toute référence à des mocks ou stubs\n6. Supprimer les fichiers de couverture (.lcov, coverage/)\n7. Mettre à jour .gitignore pour retirer les entrées liées aux tests",
        "testStrategy": "Vérification que le projet compile sans aucune référence aux tests. Exécuter 'flutter clean' puis 'flutter pub get' pour s'assurer qu'aucune dépendance de test n'est manquante.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Suppression du répertoire /test et /integration_test",
            "description": "Supprimer complètement les répertoires de tests et vérifier qu'aucun fichier de test n'est présent ailleurs",
            "dependencies": [],
            "details": "Exécuter 'rm -rf test/' et 'rm -rf integration_test/' depuis la racine du projet. Utiliser 'find . -name \"*_test.dart\" -o -name \"*.test.dart\"' pour identifier tout fichier de test restant dans d'autres répertoires. Supprimer également test_driver/ si présent.",
            "status": "done",
            "testStrategy": "Vérifier avec 'ls -la' que les répertoires n'existent plus et que la commande find ne retourne aucun résultat"
          },
          {
            "id": 2,
            "title": "Nettoyage des dépendances de test dans pubspec.yaml",
            "description": "Retirer toutes les dépendances liées aux tests de dev_dependencies tout en conservant flutter_test",
            "dependencies": [
              "2.1"
            ],
            "details": "Ouvrir pubspec.yaml et supprimer de dev_dependencies : test:, mockito:, build_runner: (si utilisé uniquement pour les mocks), mocktail:, faker:, et autres packages de test. Conserver uniquement flutter_test: et flutter_lints:. Exécuter 'flutter pub get' après modification.",
            "status": "done",
            "testStrategy": "Vérifier que 'flutter pub get' s'exécute sans erreur et que pubspec.lock est mis à jour sans les dépendances supprimées"
          },
          {
            "id": 3,
            "title": "Suppression des imports et références aux tests dans le code",
            "description": "Rechercher et supprimer tous les imports de packages de test et références aux mocks dans le code de production",
            "dependencies": [
              "2.2"
            ],
            "details": "Utiliser 'grep -r \"import.*test\" lib/' et 'grep -r \"import.*mock\" lib/' pour trouver les imports résiduels. Rechercher également les annotations @visibleForTesting et les supprimer. Vérifier dans lib/core/, lib/features/ et tout autre répertoire source.",
            "status": "done",
            "testStrategy": "Exécuter 'flutter analyze' pour s'assurer qu'aucune erreur d'import manquant n'apparaît"
          },
          {
            "id": 4,
            "title": "Suppression des fichiers de couverture et artefacts de test",
            "description": "Éliminer tous les fichiers et dossiers générés par les tests et la couverture de code",
            "dependencies": [
              "2.3"
            ],
            "details": "Supprimer : coverage/, lcov.info, *.lcov, .dart_tool/test/, .dart_tool/coverage/. Rechercher et supprimer tout fichier .g.dart généré uniquement pour les mocks (mockito). Nettoyer également les fichiers temporaires de test dans .dart_tool/.",
            "status": "done",
            "testStrategy": "Vérifier que 'find . -name \"*.lcov\" -o -name \"coverage\" -type d' ne retourne aucun résultat"
          },
          {
            "id": 5,
            "title": "Mise à jour de .gitignore et validation finale",
            "description": "Nettoyer .gitignore des entrées liées aux tests et valider que le projet compile sans infrastructure TDD",
            "dependencies": [
              "2.4"
            ],
            "details": "Retirer de .gitignore : /coverage/, *.lcov, test/.test_coverage.dart, et autres entrées spécifiques aux tests. Exécuter 'flutter clean' puis 'flutter pub get' pour une installation propre. Compiler l'application avec 'flutter build apk --debug' pour confirmer l'absence de dépendances manquantes.",
            "status": "done",
            "testStrategy": "L'application doit compiler avec succès et 'flutter analyze --no-fatal-infos' ne doit signaler aucune erreur liée aux tests supprimés"
          }
        ]
      },
      {
        "id": 3,
        "title": "Désactivation des Protections GitHub et CI/CD",
        "description": "Supprimer toutes les contraintes GitHub incluant protections de branches, workflows CI/CD obligatoires et règles de validation",
        "details": "1. Via l'interface GitHub ou GitHub CLI :\n   - Aller dans Settings > Branches\n   - Supprimer toutes les règles de protection sur 'main'\n   - Désactiver 'Require pull request reviews'\n   - Désactiver 'Require status checks'\n   - Désactiver 'Require branches to be up to date'\n2. Supprimer ou désactiver les workflows GitHub Actions :\n   - Supprimer tous les fichiers dans .github/workflows/\n   - Ou renommer en .github/workflows.disabled/ temporairement\n3. Supprimer les hooks Git locaux :\n   - rm -rf .git/hooks/*\n   - Supprimer scripts/install-hooks.sh et associés\n4. Mettre à jour README.md pour refléter le nouveau workflow simplifié\n5. Supprimer les badges CI/CD du README",
        "testStrategy": "Tester en pushant directement sur main sans PR. Vérifier qu'aucun workflow ne se déclenche et que le push est accepté sans validation.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Désactiver les protections de branches sur GitHub",
            "description": "Supprimer toutes les règles de protection configurées sur la branche main via l'interface GitHub ou GitHub CLI",
            "dependencies": [],
            "details": "Se connecter à l'interface GitHub du projet, naviguer vers Settings > Branches. Identifier toutes les règles de protection actives sur la branche 'main'. Désactiver systématiquement : 'Require pull request reviews before merging', 'Require status checks to pass before merging', 'Require branches to be up to date before merging', 'Include administrators', et toute autre restriction. Si utilisation de GitHub CLI : gh api repos/:owner/:repo/branches/main/protection -X DELETE",
            "status": "done",
            "testStrategy": "Créer une branche test locale, faire une modification mineure et tenter de push directement sur main sans créer de PR. Le push doit réussir sans aucune validation requise."
          },
          {
            "id": 2,
            "title": "Supprimer ou désactiver les workflows GitHub Actions",
            "description": "Éliminer tous les fichiers de workflows CI/CD dans .github/workflows/ pour empêcher leur exécution automatique",
            "dependencies": [],
            "details": "Naviguer vers le répertoire .github/workflows/. Lister tous les fichiers YAML présents (ci.yml, release.yml, etc.). Option 1 : Supprimer définitivement avec 'rm -rf .github/workflows/*.yml'. Option 2 : Créer un répertoire .github/workflows.disabled/ et déplacer tous les fichiers dedans pour conservation temporaire. Vérifier aussi la présence de .github/dependabot.yml et le supprimer/désactiver si présent.",
            "status": "done",
            "testStrategy": "Faire un commit et push sur main. Vérifier dans l'onglet Actions de GitHub qu'aucun workflow ne se déclenche. La section Actions devrait être vide ou afficher 'No workflows'."
          },
          {
            "id": 3,
            "title": "Éliminer les hooks Git locaux et scripts associés",
            "description": "Supprimer tous les hooks Git du projet ainsi que les scripts d'installation et de validation qui les gèrent",
            "dependencies": [],
            "details": "Exécuter 'rm -rf .git/hooks/*' pour supprimer tous les hooks actifs. Naviguer vers le répertoire scripts/ et identifier tous les fichiers liés aux hooks : install-hooks.sh, pre-commit-hook.sh, commit-msg-hook.sh, test-hooks.sh, validate_project.sh. Supprimer ces fichiers avec 'rm scripts/*hook*.sh scripts/validate*.sh'. Vérifier qu'aucun autre script ne fait référence aux hooks supprimés.",
            "status": "done",
            "testStrategy": "Tenter de faire un commit avec un message non conforme aux conventions. Le commit doit passer sans aucune validation. Vérifier que 'ls .git/hooks/' ne retourne aucun fichier exécutable."
          },
          {
            "id": 4,
            "title": "Mettre à jour la documentation pour refléter le nouveau workflow",
            "description": "Modifier README.md et CLAUDE.md pour supprimer toutes les références aux protections GitHub et CI/CD désactivées",
            "dependencies": [
              "3.1",
              "3.2",
              "3.3"
            ],
            "details": "Ouvrir README.md et rechercher toutes les sections mentionnant : workflows GitHub Actions, protection de branches, pull requests obligatoires, CI/CD, hooks Git. Supprimer ou commenter ces sections. Retirer tous les badges de statut CI/CD en haut du fichier. Dans CLAUDE.md, localiser la section 'Processus de Développement' et supprimer les parties sur la protection de main, les PR obligatoires et les conditions de merge. Ajouter une note temporaire indiquant que les protections sont désactivées pour accélérer le développement.",
            "status": "done",
            "testStrategy": "Relire les deux fichiers pour s'assurer qu'aucune référence aux anciennes protections ne subsiste. Vérifier que les instructions restantes sont cohérentes avec le nouveau workflow direct sur main."
          },
          {
            "id": 5,
            "title": "Valider la désactivation complète et documenter l'état",
            "description": "Effectuer une validation globale que toutes les protections sont bien désactivées et créer un fichier de statut temporaire",
            "dependencies": [
              "3.1",
              "3.2",
              "3.3",
              "3.4"
            ],
            "details": "Créer un fichier temporaire .taskmaster/PROTECTIONS_DISABLED.md listant toutes les protections désactivées avec la date. Faire un test complet : créer un fichier test, le committer avec un message simple, et pusher directement sur main. Vérifier sur GitHub que : aucune PR n'est requise, aucun workflow ne s'exécute, le commit apparaît immédiatement sur main. Documenter dans le fichier créé la procédure pour réactiver les protections si nécessaire plus tard.",
            "status": "done",
            "testStrategy": "Le push direct sur main doit fonctionner en moins de 5 secondes sans aucune intervention. Vérifier l'historique Git pour confirmer que le commit est bien sur main sans PR associée."
          }
        ]
      },
      {
        "id": 4,
        "title": "Analyse et Inventaire des Dépendances Actuelles",
        "description": "Analyser toutes les dépendances Flutter/Dart et composants Android pour préparer la mise à jour complète de la stack",
        "details": "1. Analyser pubspec.yaml :\n   - Lister toutes les dépendances avec leurs versions actuelles\n   - Identifier les dépendances critiques (Supabase, Riverpod, etc.)\n   - Noter les dépendances obsolètes ou non utilisées\n2. Analyser la configuration Android :\n   - android/build.gradle : versions de Gradle, Kotlin\n   - android/app/build.gradle : compileSdkVersion, targetSdkVersion, minSdkVersion\n   - android/gradle/wrapper/gradle-wrapper.properties : version Gradle wrapper\n3. Exécuter 'flutter pub outdated' pour voir l'état des mises à jour\n4. Créer un document temporaire listant :\n   - Version actuelle vs dernière version stable\n   - Breaking changes potentiels\n   - Ordre de mise à jour recommandé\n5. Vérifier la compatibilité Flutter SDK avec 'flutter doctor -v'",
        "testStrategy": "S'assurer que le rapport d'analyse est complet et que toutes les dépendances principales sont documentées avec leurs versions cibles.",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyser et documenter les dépendances pubspec.yaml",
            "description": "Extraire et documenter toutes les dépendances Flutter/Dart actuelles avec leurs versions, identifier les dépendances critiques et obsolètes",
            "dependencies": [],
            "details": "1. Lire et parser le fichier pubspec.yaml complet\n2. Créer une liste structurée de toutes les dépendances avec leurs versions actuelles\n3. Catégoriser les dépendances par type : critiques (Supabase, Riverpod, Freezed), UI (go_router), utilitaires, dev_dependencies\n4. Identifier les dépendances potentiellement obsolètes ou non utilisées dans le code\n5. Documenter les contraintes de version et les dépendances transitives importantes",
            "status": "pending",
            "testStrategy": "Vérifier que toutes les dépendances du pubspec.yaml sont listées et catégorisées correctement dans le document d'inventaire"
          },
          {
            "id": 2,
            "title": "Analyser la configuration Android et Gradle",
            "description": "Examiner tous les fichiers de configuration Android pour documenter les versions de SDK, Gradle, Kotlin et autres composants de build",
            "dependencies": [],
            "details": "1. Analyser android/build.gradle : versions de Gradle plugin, Kotlin, repositories utilisés\n2. Analyser android/app/build.gradle : compileSdkVersion, targetSdkVersion, minSdkVersion, buildToolsVersion\n3. Vérifier android/gradle/wrapper/gradle-wrapper.properties : version exacte du Gradle wrapper\n4. Examiner android/gradle.properties pour les flags de configuration (AndroidX, Jetifier)\n5. Noter les dépendances Android natives si présentes\n6. Documenter la version Java requise (JavaVersion.VERSION_17)",
            "status": "pending",
            "testStrategy": "S'assurer que toutes les versions Android/Gradle sont documentées et cohérentes avec les requirements Flutter 3.32.6"
          },
          {
            "id": 3,
            "title": "Exécuter et analyser flutter pub outdated",
            "description": "Lancer la commande flutter pub outdated pour obtenir l'état actuel des mises à jour disponibles et analyser les résultats",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Exécuter 'flutter pub outdated' dans le terminal\n2. Capturer et analyser la sortie complète incluant : versions actuelles, versions upgradables, dernières versions\n3. Identifier les packages avec des mises à jour majeures disponibles (breaking changes potentiels)\n4. Noter les packages qui sont déjà à jour\n5. Créer une matrice de compatibilité entre les versions pour éviter les conflits\n6. Prioriser les mises à jour selon leur criticité et interdépendances",
            "status": "pending",
            "testStrategy": "Vérifier que la sortie de flutter pub outdated est complètement analysée et que chaque package est catégorisé selon son statut de mise à jour"
          },
          {
            "id": 4,
            "title": "Vérifier l'environnement Flutter et documenter la compatibilité",
            "description": "Exécuter flutter doctor et analyser la compatibilité de l'environnement de développement avec les dépendances actuelles",
            "dependencies": [
              "4.2"
            ],
            "details": "1. Exécuter 'flutter doctor -v' pour obtenir les détails complets de l'environnement\n2. Documenter la version Flutter SDK actuelle (3.32.6) et Dart (3.8.1)\n3. Vérifier la compatibilité des outils : Android toolchain, Android Studio, VS Code\n4. Noter les éventuels warnings ou issues signalés par flutter doctor\n5. Vérifier que Java 17 est bien configuré pour Android 34\n6. Documenter les contraintes de compatibilité entre Flutter SDK et les dépendances principales",
            "status": "pending",
            "testStrategy": "S'assurer que flutter doctor passe sans erreur critique et que toutes les versions d'outils sont documentées"
          },
          {
            "id": 5,
            "title": "Créer le rapport d'inventaire complet avec recommandations",
            "description": "Compiler toutes les analyses dans un document structuré avec l'ordre de mise à jour recommandé et les risques identifiés",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "1. Créer un fichier temporaire .taskmaster/reports/dependency-inventory.md\n2. Structurer le rapport en sections : Dépendances Flutter, Configuration Android, État des mises à jour\n3. Pour chaque dépendance critique, documenter : version actuelle, version cible, breaking changes connus, risques\n4. Établir un ordre de mise à jour optimal : Android/Gradle d'abord, puis Flutter core, puis packages critiques\n5. Identifier les dépendances qui peuvent être mises à jour en groupe\n6. Ajouter une section de recommandations avec les précautions à prendre",
            "status": "pending",
            "testStrategy": "Valider que le rapport contient toutes les informations nécessaires pour procéder aux mises à jour sans risque d'oubli ou de conflit"
          }
        ]
      },
      {
        "id": 5,
        "title": "Mise à Jour de Flutter SDK et Dart",
        "description": "Mettre à jour Flutter vers la dernière version stable et s'assurer que l'environnement de développement est optimal",
        "details": "1. Vérifier la version actuelle : 'flutter --version'\n2. Passer sur le channel stable : 'flutter channel stable'\n3. Mettre à jour Flutter : 'flutter upgrade --force'\n4. Vérifier les outils : 'flutter doctor -v'\n5. Résoudre tous les problèmes signalés par flutter doctor\n6. Mettre à jour les contraintes SDK dans pubspec.yaml :\n   environment:\n     sdk: '>=3.0.0 <4.0.0'\n     flutter: '>=3.22.0'\n7. Si nécessaire, mettre à jour les outils de développement :\n   - Android Studio et plugins Flutter/Dart\n   - VS Code et extensions\n   - Xcode (si développement iOS prévu)\n8. Nettoyer le cache : 'flutter clean' puis 'flutter pub cache clean'",
        "testStrategy": "Exécuter 'flutter doctor' et s'assurer que tous les checks sont verts. Compiler un projet vide pour valider l'installation.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Vérifier et documenter l'environnement Flutter actuel",
            "description": "Analyser l'état actuel de Flutter SDK, Dart et l'environnement de développement pour identifier les mises à jour nécessaires",
            "dependencies": [],
            "details": "Exécuter 'flutter --version' et documenter la version actuelle de Flutter, Dart SDK, et le channel actif. Exécuter 'flutter doctor -v' pour obtenir un rapport détaillé de l'environnement incluant Android toolchain, IDE, et éventuels problèmes. Sauvegarder ces informations dans un fichier pour référence future avant la mise à jour.",
            "status": "pending",
            "testStrategy": "Vérifier que le rapport est complet avec toutes les versions documentées et que 'flutter doctor' s'exécute sans erreur critique"
          },
          {
            "id": 2,
            "title": "Basculer sur le channel stable et mettre à jour Flutter",
            "description": "Changer vers le channel stable de Flutter et effectuer la mise à jour complète du SDK",
            "dependencies": [
              "5.1"
            ],
            "details": "Exécuter 'flutter channel stable' pour basculer sur le channel de production. Ensuite, exécuter 'flutter upgrade --force' pour forcer la mise à jour vers la dernière version stable. Cette opération peut prendre plusieurs minutes selon la connexion internet. Documenter la nouvelle version obtenue après la mise à jour.",
            "status": "pending",
            "testStrategy": "Confirmer le changement de channel avec 'flutter channel' et vérifier la nouvelle version avec 'flutter --version'"
          },
          {
            "id": 3,
            "title": "Résoudre les problèmes identifiés par flutter doctor",
            "description": "Corriger tous les avertissements et erreurs signalés par flutter doctor pour avoir un environnement optimal",
            "dependencies": [
              "5.2"
            ],
            "details": "Analyser le rapport de 'flutter doctor -v' après la mise à jour. Résoudre chaque problème identifié : installer les Android SDK manquants, accepter les licences avec 'flutter doctor --android-licenses', mettre à jour les plugins IDE si nécessaire. S'assurer que toutes les dépendances système sont correctement configurées.",
            "status": "pending",
            "testStrategy": "Exécuter 'flutter doctor' jusqu'à obtenir tous les checks en vert sans avertissement"
          },
          {
            "id": 4,
            "title": "Mettre à jour les contraintes SDK dans pubspec.yaml",
            "description": "Adapter les contraintes de versions SDK dans le fichier pubspec.yaml pour correspondre aux nouvelles versions",
            "dependencies": [
              "5.2"
            ],
            "details": "Modifier pubspec.yaml pour mettre à jour les contraintes d'environnement selon les versions actuelles. Définir sdk: '>=3.8.0 <4.0.0' et flutter: '>=3.32.0' basé sur la version installée. S'assurer que ces contraintes sont compatibles avec toutes les dépendances du projet. Exécuter 'flutter pub get' pour valider les changements.",
            "status": "pending",
            "testStrategy": "Vérifier que 'flutter pub get' s'exécute sans erreur de compatibilité SDK"
          },
          {
            "id": 5,
            "title": "Nettoyer le cache et valider l'installation",
            "description": "Effectuer un nettoyage complet du cache Flutter et valider que l'environnement mis à jour fonctionne correctement",
            "dependencies": [
              "5.3",
              "5.4"
            ],
            "details": "Exécuter 'flutter clean' pour nettoyer les artifacts de build. Puis exécuter 'flutter pub cache clean' et confirmer avec 'y' pour vider le cache des packages. Réinstaller les dépendances avec 'flutter pub get'. Créer et compiler un projet Flutter vide pour valider que toute la toolchain fonctionne correctement après la mise à jour.",
            "status": "pending",
            "testStrategy": "Créer un nouveau projet avec 'flutter create test_app', naviguer dedans et exécuter 'flutter run' pour confirmer la compilation et l'exécution"
          }
        ]
      },
      {
        "id": 6,
        "title": "Mise à Jour des Composants Android",
        "description": "Moderniser toute la configuration Android incluant Gradle, Kotlin, et les SDK versions pour assurer la compatibilité avec les derniers standards",
        "details": "1. Mettre à jour android/gradle/wrapper/gradle-wrapper.properties :\n   - distributionUrl vers Gradle 8.9 ou dernière version stable\n2. Mettre à jour android/build.gradle :\n   - com.android.tools.build:gradle vers 8.7.2+\n   - kotlin_version vers 2.0.0+\n   - Ajouter les repositories Google Maven si manquants\n3. Mettre à jour android/app/build.gradle :\n   - compileSdkVersion 35\n   - targetSdkVersion 35\n   - minSdkVersion 23 (ou selon besoins)\n   - Namespace obligatoire pour AGP 8+\n4. Migrer vers les nouvelles APIs Android si nécessaire\n5. Mettre à jour ProGuard/R8 rules si utilisé\n6. Vérifier AndroidManifest.xml pour deprecated attributes\n7. S'assurer que Java 17+ est utilisé pour la compilation\n8. Tester la compilation : 'flutter build apk --debug'",
        "testStrategy": "Compiler l'APK en debug et release. Vérifier qu'aucun warning de dépréciation n'apparaît. Tester sur émulateur Android récent.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Mettre à jour Gradle Wrapper vers la version 8.12",
            "description": "Moderniser le fichier gradle-wrapper.properties pour utiliser la dernière version LTS de Gradle compatible avec AGP 8.x",
            "dependencies": [],
            "details": "Modifier android/gradle/wrapper/gradle-wrapper.properties pour définir distributionUrl=https://services.gradle.org/distributions/gradle-8.12-all.zip. Vérifier la compatibilité avec le plugin Android Gradle 8.7.2+. S'assurer que le checksum est correct et que la distribution 'all' est utilisée pour le support complet des fonctionnalités.",
            "status": "pending",
            "testStrategy": "Exécuter ./gradlew --version dans le répertoire android pour confirmer la version. Lancer flutter clean puis flutter build apk --debug pour valider la compatibilité."
          },
          {
            "id": 2,
            "title": "Moderniser la configuration Gradle racine et Kotlin",
            "description": "Mettre à jour android/build.gradle avec les dernières versions du plugin Android Gradle et de Kotlin",
            "dependencies": [
              "6.1"
            ],
            "details": "Dans android/build.gradle : mettre à jour com.android.tools.build:gradle vers 8.7.2, kotlin_version vers 2.0.21, et org.jetbrains.kotlin:kotlin-gradle-plugin vers la même version. Ajouter google() et mavenCentral() dans allprojects.repositories si manquants. Configurer Java 17 avec compileOptions et kotlinOptions.",
            "status": "pending",
            "testStrategy": "Synchroniser le projet Gradle et vérifier l'absence d'erreurs de résolution de dépendances. Compiler un APK debug pour valider."
          },
          {
            "id": 3,
            "title": "Configurer les SDK Android et namespace dans app/build.gradle",
            "description": "Mettre à jour les versions SDK et ajouter le namespace obligatoire pour AGP 8+",
            "dependencies": [
              "6.2"
            ],
            "details": "Dans android/app/build.gradle : définir compileSdk 35, targetSdk 35, minSdk 23. Ajouter namespace 'com.ojyx.app' dans le bloc android. Configurer compileOptions avec sourceCompatibility et targetCompatibility JavaVersion.VERSION_17. Vérifier buildToolsVersion et le mettre à jour vers 35.0.0 si nécessaire.",
            "status": "pending",
            "testStrategy": "Compiler l'application avec flutter build apk --debug et --release. Vérifier l'absence de warnings de dépréciation dans les logs Gradle."
          },
          {
            "id": 4,
            "title": "Nettoyer AndroidManifest.xml et migrer les attributs dépréciés",
            "description": "Réviser le fichier manifest pour supprimer les attributs obsolètes et adopter les nouvelles pratiques Android",
            "dependencies": [
              "6.3"
            ],
            "details": "Examiner android/app/src/main/AndroidManifest.xml pour identifier et remplacer les attributs dépréciés. Supprimer android:allowBackup si présent (géré par défaut). Vérifier android:exported sur toutes les activités. Mettre à jour les permissions si nécessaire. S'assurer que le package correspond au namespace défini dans build.gradle.",
            "status": "pending",
            "testStrategy": "Analyser avec Android Lint pour détecter les problèmes. Installer l'APK sur un émulateur Android 14+ et vérifier le bon fonctionnement."
          },
          {
            "id": 5,
            "title": "Configurer ProGuard/R8 et valider la compilation complète",
            "description": "Optimiser les règles de minification et effectuer une validation complète de la configuration Android modernisée",
            "dependencies": [
              "6.4"
            ],
            "details": "Vérifier android/app/proguard-rules.pro et ajouter les règles nécessaires pour Flutter et les dépendances. Activer R8 dans gradle.properties avec android.enableR8=true. Tester la compilation release avec minification activée. Documenter tous les changements dans un fichier ANDROID_UPGRADE.md pour référence future.",
            "status": "pending",
            "testStrategy": "Compiler flutter build apk --release avec ProGuard actif. Installer et tester l'APK sur plusieurs versions d'Android (API 23, 28, 34). Mesurer la taille de l'APK avant/après optimisation."
          }
        ]
      },
      {
        "id": 7,
        "title": "Mise à Jour de Supabase et Dépendances Critiques",
        "description": "Mettre à jour Supabase Flutter vers la dernière version stable et adapter le code pour les breaking changes",
        "details": "1. Consulter la documentation Supabase via MCP context7 pour la dernière version\n2. Mettre à jour dans pubspec.yaml :\n   - supabase_flutter: ^2.8.0+ (ou dernière)\n   - supabase: ^2.5.0+ (si utilisé séparément)\n3. Vérifier les breaking changes dans le changelog Supabase\n4. Adapter l'initialisation Supabase si changée :\n   - Supabase.initialize() parameters\n   - Configuration auth\n   - Realtime subscriptions syntax\n5. Mettre à jour les imports si modifiés\n6. Adapter les appels API selon nouvelle syntaxe :\n   - CRUD operations\n   - Auth flows\n   - Storage operations\n   - Realtime channels\n7. Vérifier la compatibilité avec les Edge Functions\n8. Tester la connexion : créer un test rapide de connexion Supabase",
        "testStrategy": "Créer un test de connexion simple qui vérifie l'authentification anonyme et une requête basique à une table. Vérifier les logs pour absence d'erreurs.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Recherche et Analyse de la Dernière Version Supabase",
            "description": "Utiliser MCP context7 pour consulter la documentation officielle Supabase et identifier la dernière version stable avec ses breaking changes",
            "dependencies": [],
            "details": "1. Utiliser mcp__context7__resolve-library-id avec 'supabase' pour obtenir l'ID de la bibliothèque\n2. Utiliser mcp__context7__get-library-docs pour récupérer la documentation sur les versions et migrations\n3. Identifier la dernière version stable de supabase_flutter (actuellement 2.8.0+)\n4. Compiler une liste des breaking changes depuis la version actuelle\n5. Noter les changements d'API critiques affectant l'auth, le realtime et le storage",
            "status": "pending",
            "testStrategy": "Vérifier que la documentation récupérée contient les informations de version et de migration nécessaires"
          },
          {
            "id": 2,
            "title": "Mise à Jour des Dépendances Supabase dans pubspec.yaml",
            "description": "Modifier pubspec.yaml pour utiliser les dernières versions stables de Supabase et vérifier la compatibilité",
            "dependencies": [
              "7.1"
            ],
            "details": "1. Ouvrir pubspec.yaml et localiser les dépendances Supabase actuelles\n2. Mettre à jour supabase_flutter vers la dernière version identifiée (ex: ^2.8.0)\n3. Si présent, mettre à jour supabase séparément (^2.5.0+)\n4. Exécuter 'flutter pub get' pour télécharger les nouvelles versions\n5. Vérifier les messages d'erreur ou avertissements de compatibilité\n6. Si nécessaire, ajuster les contraintes de version pour résoudre les conflits",
            "status": "pending",
            "testStrategy": "Exécuter 'flutter pub get' sans erreurs et vérifier que les dépendances sont correctement résolues"
          },
          {
            "id": 3,
            "title": "Adaptation du Code d'Initialisation et Configuration",
            "description": "Modifier le code d'initialisation Supabase selon la nouvelle syntaxe et adapter la configuration auth et realtime",
            "dependencies": [
              "7.2"
            ],
            "details": "1. Localiser l'initialisation Supabase (généralement dans main.dart ou un fichier de configuration)\n2. Adapter Supabase.initialize() avec les nouveaux paramètres requis\n3. Mettre à jour la configuration d'authentification (authFlowType, etc.)\n4. Modifier la syntaxe des souscriptions realtime si changée\n5. Adapter les paramètres de persistance et de session\n6. Vérifier les imports et les mettre à jour si nécessaire\n7. S'assurer que les variables d'environnement sont correctement passées",
            "status": "pending",
            "testStrategy": "L'application doit démarrer sans erreur et l'initialisation Supabase doit se faire correctement dans les logs"
          },
          {
            "id": 4,
            "title": "Migration des Appels API et Opérations CRUD",
            "description": "Adapter tous les appels Supabase (CRUD, auth, storage) selon la nouvelle syntaxe de l'API",
            "dependencies": [
              "7.3"
            ],
            "details": "1. Rechercher tous les fichiers utilisant Supabase client (datasources, repositories)\n2. Mettre à jour les opérations CRUD :\n   - select(), insert(), update(), delete()\n   - Nouvelles syntaxes pour les filtres et jointures\n3. Adapter les flows d'authentification :\n   - signIn, signUp, signOut\n   - Gestion des sessions et tokens\n4. Modifier les opérations de storage si nécessaire\n5. Mettre à jour la gestion des erreurs selon les nouveaux types\n6. Adapter les edge functions calls si utilisés",
            "status": "pending",
            "testStrategy": "Créer des tests unitaires pour chaque type d'opération (CRUD, auth, storage) vérifiant le bon fonctionnement"
          },
          {
            "id": 5,
            "title": "Test d'Intégration et Validation Complète",
            "description": "Créer et exécuter un test complet vérifiant la connexion Supabase, l'auth anonyme et les opérations basiques",
            "dependencies": [
              "7.4"
            ],
            "details": "1. Créer un test d'intégration dans test/integration/supabase_test.dart\n2. Implémenter un test de connexion vérifiant l'initialisation\n3. Tester l'authentification anonyme (signInAnonymously)\n4. Effectuer une requête simple sur une table de test\n5. Vérifier les souscriptions realtime fonctionnent\n6. Tester une opération de storage basique si utilisé\n7. Examiner les logs pour détecter des warnings ou dépréciations\n8. Documenter tout problème résiduel dans les commentaires du code",
            "status": "pending",
            "testStrategy": "Tous les tests d'intégration doivent passer et aucune erreur/warning lié à Supabase ne doit apparaître dans les logs"
          }
        ]
      },
      {
        "id": 8,
        "title": "Mise à Jour de Riverpod et State Management",
        "description": "Migrer vers la dernière version de Riverpod et adapter tous les providers selon la syntaxe moderne avec annotations",
        "details": "1. Mettre à jour les dépendances Riverpod :\n   - flutter_riverpod: ^2.6.1+\n   - riverpod_annotation: ^2.6.1+\n   - riverpod_generator: ^2.6.1+ (dev)\n   - riverpod_lint: ^2.6.1+ (dev)\n2. Migrer vers la syntaxe @riverpod :\n   - Remplacer les providers legacy par annotations\n   - Utiliser part files pour la génération\n   - Adopter les Notifier modernes\n3. Mettre à jour build_runner si nécessaire\n4. Régénérer tous les fichiers : 'flutter pub run build_runner build --delete-conflicting-outputs'\n5. Adapter les ConsumerWidget et ConsumerStatefulWidget\n6. Migrer les AsyncNotifier pour les états async\n7. Utiliser les nouvelles méthodes ref.watch, ref.read\n8. Implémenter l'auto-dispose correctement\n9. Configurer riverpod_lint dans analysis_options.yaml",
        "testStrategy": "Compiler le projet et vérifier qu'aucune erreur Riverpod n'apparaît. Tester que la génération de code fonctionne correctement.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Mise à jour des dépendances Riverpod dans pubspec.yaml",
            "description": "Mettre à jour toutes les dépendances Riverpod vers les versions 2.6.1+ et ajouter les nouveaux packages nécessaires pour la génération de code",
            "dependencies": [],
            "details": "1. Ouvrir pubspec.yaml\n2. Mettre à jour les dépendances :\n   - flutter_riverpod: ^2.6.1\n   - riverpod_annotation: ^2.6.1\n3. Ajouter les dev_dependencies :\n   - riverpod_generator: ^2.6.1\n   - riverpod_lint: ^2.6.1\n   - build_runner: ^2.4.0 (si pas déjà présent ou version obsolète)\n4. Exécuter 'flutter pub get' pour télécharger les nouvelles dépendances\n5. Vérifier qu'aucun conflit de version n'est signalé",
            "status": "pending",
            "testStrategy": "Exécuter 'flutter pub get' sans erreur. Vérifier que 'flutter pub deps' montre les bonnes versions de Riverpod installées."
          },
          {
            "id": 2,
            "title": "Configuration de riverpod_lint et analysis_options.yaml",
            "description": "Configurer riverpod_lint dans analysis_options.yaml pour bénéficier des lints et suggestions spécifiques à Riverpod",
            "dependencies": [
              "8.1"
            ],
            "details": "1. Ouvrir ou créer analysis_options.yaml à la racine du projet\n2. Ajouter riverpod_lint aux plugins d'analyse :\n   analyzer:\n     plugins:\n       - riverpod_lint\n3. Activer les règles recommandées pour Riverpod\n4. Configurer les exclusions si nécessaire (fichiers générés, etc.)\n5. Exécuter 'flutter analyze' pour vérifier que la configuration est correcte\n6. Corriger les avertissements initiaux signalés par riverpod_lint",
            "status": "pending",
            "testStrategy": "Exécuter 'flutter analyze' et vérifier que riverpod_lint est actif et fonctionne. Aucune erreur de configuration ne doit apparaître."
          },
          {
            "id": 3,
            "title": "Migration des providers legacy vers la syntaxe @riverpod",
            "description": "Parcourir tous les fichiers providers existants et les migrer vers la nouvelle syntaxe avec annotations @riverpod et génération de code",
            "dependencies": [
              "8.2"
            ],
            "details": "1. Identifier tous les fichiers contenant des providers Riverpod (rechercher 'Provider', 'StateNotifierProvider', etc.)\n2. Pour chaque fichier provider :\n   - Ajouter l'import : import 'package:riverpod_annotation/riverpod_annotation.dart';\n   - Ajouter la directive part : part 'nom_fichier.g.dart';\n   - Remplacer les providers legacy par des fonctions annotées @riverpod\n   - Convertir StateNotifierProvider en classes annotées @riverpod\n3. Exemples de migration :\n   - final myProvider = Provider((ref) => ...) devient @riverpod\n     MyType myProvider(MyProviderRef ref) => ...\n   - Les StateNotifier deviennent des classes Notifier annotées\n4. Maintenir la logique métier identique",
            "status": "pending",
            "testStrategy": "Chaque fichier migré doit avoir sa syntaxe validée par l'analyseur. La génération de code doit réussir pour chaque provider migré."
          },
          {
            "id": 4,
            "title": "Migration des StateNotifier vers Notifier/AsyncNotifier modernes",
            "description": "Convertir toutes les classes StateNotifier existantes vers les nouvelles classes Notifier ou AsyncNotifier selon le cas d'usage",
            "dependencies": [
              "8.3"
            ],
            "details": "1. Identifier toutes les classes étendant StateNotifier\n2. Pour chaque StateNotifier :\n   - Si l'état est synchrone : migrer vers Notifier<T>\n   - Si l'état est asynchrone : migrer vers AsyncNotifier<T>\n3. Étapes de migration :\n   - Remplacer 'extends StateNotifier<T>' par 'extends _$NomClasse'\n   - Ajouter l'annotation @riverpod sur la classe\n   - Remplacer le constructeur par la méthode build()\n   - Adapter les méthodes pour utiliser state directement\n   - Gérer les AsyncValue pour les AsyncNotifier\n4. Mettre à jour les références dans les widgets consumers\n5. Supprimer les anciens StateNotifierProvider",
            "status": "pending",
            "testStrategy": "Compiler le code après chaque migration. Vérifier que les Notifier générés fonctionnent correctement avec des tests manuels de l'état."
          },
          {
            "id": 5,
            "title": "Génération du code et adaptation des widgets consumers",
            "description": "Exécuter la génération de code pour tous les providers migrés et adapter les ConsumerWidget/ConsumerStatefulWidget pour utiliser la nouvelle syntaxe",
            "dependencies": [
              "8.4"
            ],
            "details": "1. Exécuter la génération de code complète :\n   flutter pub run build_runner build --delete-conflicting-outputs\n2. Vérifier que tous les fichiers .g.dart sont générés sans erreur\n3. Adapter les widgets consumers :\n   - Mettre à jour les appels ref.watch() avec les nouveaux providers générés\n   - Remplacer ref.read() où nécessaire\n   - Utiliser les nouvelles méthodes des Notifier\n4. Implémenter l'auto-dispose correctement :\n   - Utiliser @riverpod(keepAlive: false) pour l'auto-dispose\n   - Vérifier le cycle de vie des providers\n5. Tester l'application complète pour valider les changements\n6. Corriger les derniers warnings de riverpod_lint",
            "status": "pending",
            "testStrategy": "L'application doit compiler sans erreur. Tous les providers doivent fonctionner correctement. Aucun warning Riverpod dans 'flutter analyze'."
          }
        ]
      },
      {
        "id": 9,
        "title": "Mise à Jour des Autres Dépendances Flutter",
        "description": "Mettre à jour toutes les autres dépendances vers leurs dernières versions stables incluant Freezed, go_router, et utilitaires",
        "details": "1. Mettre à jour les dépendances de génération de code :\n   - freezed: ^2.5.7+\n   - json_serializable: ^6.9.0+\n   - freezed_annotation: ^2.4.4+\n   - json_annotation: ^4.9.0+\n2. Mettre à jour go_router vers 14.6.0+ :\n   - Vérifier les breaking changes dans la navigation\n   - Adapter la configuration des routes si nécessaire\n3. Mettre à jour les utilitaires :\n   - path_provider: dernière version\n   - shared_preferences: dernière version\n   - url_launcher: dernière version\n4. Mettre à jour les UI packages :\n   - flutter_svg si utilisé\n   - cached_network_image si utilisé\n5. Mettre à jour dev_dependencies :\n   - flutter_lints: ^5.0.0+\n   - build_runner: ^2.4.13+\n6. Exécuter 'flutter pub upgrade --major-versions'\n7. Résoudre les conflits de versions\n8. Régénérer le code avec build_runner",
        "testStrategy": "Exécuter 'flutter pub get' sans erreur. Vérifier que la génération de code fonctionne. Compiler l'application complète.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Mise à jour des dépendances de génération de code",
            "description": "Mettre à jour Freezed, json_serializable et leurs annotations vers les dernières versions stables",
            "dependencies": [],
            "details": "1. Mettre à jour dans pubspec.yaml :\n   - freezed: ^2.5.7 ou version supérieure stable\n   - json_serializable: ^6.9.0 ou version supérieure stable\n   - freezed_annotation: ^2.4.4 ou version supérieure stable\n   - json_annotation: ^4.9.0 ou version supérieure stable\n2. Vérifier la compatibilité entre les versions\n3. Consulter les changelogs pour identifier les breaking changes\n4. Adapter les imports si nécessaire\n5. Préparer les commandes de régénération du code",
            "status": "pending",
            "testStrategy": "Exécuter 'flutter pub get' sans erreur. Vérifier que build_runner peut démarrer sans conflit de versions."
          },
          {
            "id": 2,
            "title": "Mise à jour de go_router et adaptation de la navigation",
            "description": "Mettre à jour go_router vers la version 14.6.0+ et adapter le code de navigation si nécessaire",
            "dependencies": [
              "9.1"
            ],
            "details": "1. Mettre à jour go_router dans pubspec.yaml vers ^14.6.0\n2. Analyser les breaking changes depuis la version actuelle :\n   - Changements dans GoRoute et GoRouter\n   - Modifications des redirections et guards\n   - Évolution de la syntaxe des paramètres\n3. Adapter lib/core/config/router_config.dart :\n   - Mettre à jour la syntaxe des routes\n   - Adapter les redirections si nécessaire\n   - Vérifier les paramètres de route\n4. Rechercher et corriger tous les usages de context.go(), context.push()\n5. Tester la navigation sur toutes les routes principales",
            "status": "pending",
            "testStrategy": "Compiler l'application et naviguer manuellement entre tous les écrans principaux pour vérifier que la navigation fonctionne correctement."
          },
          {
            "id": 3,
            "title": "Mise à jour des packages utilitaires essentiels",
            "description": "Mettre à jour path_provider, shared_preferences, url_launcher et autres utilitaires vers leurs dernières versions",
            "dependencies": [
              "9.1"
            ],
            "details": "1. Identifier les versions actuelles et cibles :\n   - path_provider: dernière version stable\n   - shared_preferences: dernière version stable\n   - url_launcher: dernière version stable\n2. Mettre à jour dans pubspec.yaml\n3. Vérifier les changements d'API :\n   - Méthodes dépréciées\n   - Nouveaux paramètres requis\n   - Changements de comportement\n4. Adapter le code si nécessaire :\n   - Mise à jour des imports\n   - Adaptation des appels de méthodes\n5. Vérifier les permissions Android/iOS si nécessaire",
            "status": "pending",
            "testStrategy": "Tester les fonctionnalités utilisant ces packages : sauvegarde de préférences, ouverture d'URLs, accès aux fichiers."
          },
          {
            "id": 4,
            "title": "Mise à jour des dépendances de développement et linting",
            "description": "Mettre à jour flutter_lints, build_runner et autres dev_dependencies vers leurs dernières versions",
            "dependencies": [
              "9.1",
              "9.2",
              "9.3"
            ],
            "details": "1. Mettre à jour dans dev_dependencies :\n   - flutter_lints: ^5.0.0 ou supérieur\n   - build_runner: ^2.4.13 ou supérieur\n   - Autres dev_dependencies identifiées\n2. Adapter analysis_options.yaml si nécessaire :\n   - Nouvelles règles de linting\n   - Règles dépréciées à retirer\n3. Corriger les warnings de linting apparus :\n   - Utiliser 'dart fix --apply' si applicable\n   - Corrections manuelles pour les cas complexes\n4. Vérifier que les scripts de génération fonctionnent\n5. Mettre à jour les configurations IDE si nécessaire",
            "status": "pending",
            "testStrategy": "Exécuter 'flutter analyze' et s'assurer qu'il n'y a pas de nouvelles erreurs. Vérifier que 'dart format .' fonctionne correctement."
          },
          {
            "id": 5,
            "title": "Finalisation et validation complète des mises à jour",
            "description": "Exécuter les commandes de mise à jour globale, régénérer le code et valider le bon fonctionnement de l'application",
            "dependencies": [
              "9.1",
              "9.2",
              "9.3",
              "9.4"
            ],
            "details": "1. Exécuter 'flutter pub upgrade --major-versions' pour capturer les dernières versions\n2. Résoudre tous les conflits de versions :\n   - Analyser les messages d'erreur\n   - Ajuster les contraintes de version si nécessaire\n3. Régénérer tout le code :\n   - 'flutter pub run build_runner build --delete-conflicting-outputs'\n   - Corriger les erreurs de génération\n4. Nettoyer et reconstruire :\n   - 'flutter clean'\n   - 'flutter pub get'\n5. Compiler et tester l'application complète :\n   - Mode debug et release\n   - Vérifier toutes les fonctionnalités principales",
            "status": "pending",
            "testStrategy": "L'application doit compiler sans erreur en mode debug et release. Toutes les fonctionnalités principales doivent être testées manuellement."
          }
        ]
      },
      {
        "id": 10,
        "title": "Adaptation du Code aux Breaking Changes",
        "description": "Parcourir tout le codebase et adapter le code pour qu'il compile avec toutes les nouvelles versions des dépendances",
        "details": "1. Exécuter 'flutter analyze' et noter toutes les erreurs\n2. Corriger les imports obsolètes ou modifiés\n3. Adapter la syntaxe Riverpod :\n   - Migrer les StateNotifier vers Notifier/AsyncNotifier\n   - Utiliser les bonnes annotations @riverpod\n4. Corriger les appels Supabase selon nouvelle API\n5. Adapter go_router si syntaxe changée :\n   - GoRoute configuration\n   - Navigation methods\n   - Guards et redirects\n6. Mettre à jour les widgets dépréciés\n7. Corriger les null-safety issues\n8. Adapter les générateurs Freezed si syntaxe modifiée\n9. Résoudre tous les warnings\n10. S'assurer que 'flutter analyze' passe sans erreur\n11. Formater le code : 'dart format .'",
        "testStrategy": "Le projet doit compiler sans erreur ni warning. 'flutter analyze' doit passer. L'application doit se lancer sur émulateur.",
        "priority": "high",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyse initiale des erreurs de compilation",
            "description": "Exécuter flutter analyze pour identifier toutes les erreurs de compilation et les classer par catégorie (imports, syntaxe, API obsolètes)",
            "dependencies": [],
            "details": "1. Exécuter 'flutter clean' pour partir d'un état propre\n2. Exécuter 'flutter pub get' pour télécharger les dépendances mises à jour\n3. Exécuter 'flutter analyze --no-fatal-infos > analyze_report.txt' pour capturer toutes les erreurs\n4. Classifier les erreurs par type :\n   - Imports manquants ou obsolètes\n   - Erreurs de syntaxe Riverpod\n   - API Supabase obsolètes\n   - Problèmes go_router\n   - Widgets dépréciés\n   - Null-safety issues\n5. Créer un document de suivi avec le nombre d'erreurs par catégorie\n6. Prioriser les corrections par ordre de blocage (imports d'abord, puis syntaxe, puis API)",
            "status": "pending",
            "testStrategy": "Vérifier que le rapport d'analyse est généré avec toutes les erreurs catégorisées. S'assurer qu'aucune erreur n'est manquée en comparant avec l'output direct de flutter analyze."
          },
          {
            "id": 2,
            "title": "Correction des imports et migration Riverpod",
            "description": "Corriger tous les imports obsolètes et migrer la syntaxe Riverpod vers les patterns modernes avec Notifier et annotations @riverpod",
            "dependencies": [
              "10.1"
            ],
            "details": "1. Corriger les imports obsolètes :\n   - Remplacer les anciens paths par les nouveaux\n   - Supprimer les imports non utilisés\n   - Ajouter les imports manquants pour les nouvelles APIs\n2. Migration Riverpod complète :\n   - Identifier tous les StateNotifier et les convertir en Notifier/AsyncNotifier\n   - Remplacer l'ancienne syntaxe par les annotations @riverpod\n   - Migrer les ConsumerWidget/ConsumerStatefulWidget si nécessaire\n   - Adapter les refs et watch/read selon nouvelle syntaxe\n   - Mettre à jour les providers avec les bons types génériques\n3. Régénérer les fichiers avec build_runner :\n   - 'flutter pub run build_runner build --delete-conflicting-outputs'\n4. Vérifier que tous les providers sont correctement typés et fonctionnels",
            "status": "pending",
            "testStrategy": "Exécuter flutter analyze après chaque groupe de corrections pour valider. S'assurer que tous les providers Riverpod sont accessibles et que les états se propagent correctement."
          },
          {
            "id": 3,
            "title": "Adaptation des APIs Supabase et go_router",
            "description": "Mettre à jour tous les appels Supabase selon la nouvelle API et adapter la configuration et utilisation de go_router",
            "dependencies": [
              "10.2"
            ],
            "details": "1. Migration Supabase :\n   - Identifier tous les appels Supabase dans le codebase\n   - Adapter les méthodes auth (signIn, signUp, signOut) selon nouvelle syntaxe\n   - Mettre à jour les queries (from, select, insert, update, delete)\n   - Corriger les listeners realtime si la syntaxe a changé\n   - Adapter la gestion des erreurs Supabase\n2. Migration go_router :\n   - Mettre à jour la configuration des routes (GoRoute, GoRouter)\n   - Adapter les méthodes de navigation (go, push, pop)\n   - Corriger les guards et redirects selon nouvelle syntaxe\n   - Vérifier les paramètres de route et query parameters\n   - S'assurer que les transitions et animations fonctionnent\n3. Tester la navigation complète de l'application\n4. Vérifier que l'authentification Supabase fonctionne end-to-end",
            "status": "pending",
            "testStrategy": "Créer un parcours utilisateur simple (login -> navigation -> action Supabase) pour valider l'intégration. Vérifier les logs pour toute erreur runtime."
          },
          {
            "id": 4,
            "title": "Résolution des widgets dépréciés et problèmes null-safety",
            "description": "Remplacer tous les widgets dépréciés par leurs équivalents modernes et corriger les problèmes de null-safety restants",
            "dependencies": [
              "10.3"
            ],
            "details": "1. Widgets dépréciés :\n   - Identifier tous les widgets marqués comme deprecated\n   - Remplacer par les alternatives recommandées (ex: FlatButton -> TextButton)\n   - Adapter les propriétés selon les nouvelles APIs\n   - Vérifier que le styling reste cohérent\n2. Null-safety issues :\n   - Corriger tous les '!' non nécessaires ou dangereux\n   - Ajouter les '?' appropriés pour les types nullable\n   - Utiliser les opérateurs null-aware (??, ?., ??=)\n   - Vérifier les late variables et leur initialisation\n   - S'assurer que les futures et streams sont correctement typés\n3. Optimiser les imports avec 'dart fix --apply'\n4. Vérifier que toutes les classes Freezed sont correctement annotées\n5. Résoudre les conflits de types génériques",
            "status": "pending",
            "testStrategy": "Compiler l'application en mode debug et release pour détecter les erreurs runtime. Vérifier qu'aucun widget ne génère d'erreur lors du rendu."
          },
          {
            "id": 5,
            "title": "Validation finale et formatage du code",
            "description": "Effectuer une validation complète du code, résoudre tous les warnings restants et formater l'ensemble du codebase",
            "dependencies": [
              "10.4"
            ],
            "details": "1. Validation exhaustive :\n   - Exécuter 'flutter analyze' et s'assurer que 0 erreur est retournée\n   - Résoudre tous les warnings restants (unused imports, variables, etc.)\n   - Vérifier les TODO et FIXME dans le code\n2. Formatage complet :\n   - Exécuter 'dart format .' sur tout le codebase\n   - Vérifier que le formatage respecte les conventions du projet\n   - S'assurer que les fichiers générés sont exclus du formatage\n3. Test de compilation :\n   - 'flutter clean' puis 'flutter pub get'\n   - Compiler en debug : 'flutter build apk --debug'\n   - Compiler en release : 'flutter build apk --release'\n4. Lancer l'application sur émulateur/device\n5. Parcourir les écrans principaux pour valider le fonctionnement\n6. Documenter les changements majeurs effectués",
            "status": "pending",
            "testStrategy": "L'application doit compiler sans erreur ni warning. Flutter analyze doit retourner 'No issues found!'. L'app doit se lancer et être navigable sur émulateur."
          }
        ]
      },
      {
        "id": 11,
        "title": "Mise à Jour de la Documentation IA (CLAUDE.md)",
        "description": "Réviser complètement CLAUDE.md et autres documents IA pour refléter l'abandon du TDD et la nouvelle philosophie Feature-First",
        "details": "1. Ouvrir CLAUDE.md et .taskmaster/CLAUDE.md\n2. Supprimer toutes les sections relatives au TDD :\n   - Règles sur l'écriture des tests en premier\n   - Workflow Red-Green-Refactor\n   - Interdictions et conséquences TDD\n3. Ajouter une nouvelle section 'Philosophie Feature-First' :\n   - Priorité absolue : livraison rapide de fonctionnalités\n   - Tests écrits après stabilisation\n   - Focus sur la simplicité et la vélocité\n4. Supprimer les références aux hooks Git de validation\n5. Simplifier les commandes essentielles\n6. Mettre à jour les versions des dépendances documentées\n7. Supprimer les références aux workflows CI/CD complexes\n8. Ajouter des exemples de développement Feature-First\n9. Réviser les instructions TaskMaster si nécessaire\n10. S'assurer que le ton reflète la nouvelle approche pragmatique",
        "testStrategy": "Relire le document pour s'assurer qu'il ne contient plus aucune référence au TDD obligatoire. Vérifier la cohérence avec la nouvelle philosophie.",
        "priority": "high",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Suppression des Sections TDD dans CLAUDE.md",
            "description": "Identifier et supprimer toutes les sections relatives au Test-Driven Development dans le fichier principal CLAUDE.md",
            "dependencies": [],
            "details": "Ouvrir CLAUDE.md et supprimer : la section 'Approche Test-First (OBLIGATOIRE ET NON-NÉGOCIABLE)', les interdictions absolues en TDD, les conséquences des violations TDD, les références aux hooks Git automatiques de validation des tests, le workflow Red-Green-Refactor, et toute mention obligatoire d'écrire les tests avant le code. Conserver uniquement les parties neutres sur les tests qui peuvent être adaptées pour des tests post-implémentation.",
            "status": "pending",
            "testStrategy": "Rechercher dans le fichier les mots-clés 'TDD', 'Test-First', 'RED-GREEN', 'test avant', 'OBLIGATOIRE' pour vérifier qu'aucune référence au TDD obligatoire ne subsiste"
          },
          {
            "id": 2,
            "title": "Ajout de la Section Philosophie Feature-First",
            "description": "Créer et rédiger une nouvelle section documentant l'approche Feature-First avec ses principes et exemples pratiques",
            "dependencies": [
              "11.1"
            ],
            "details": "Ajouter après la section Architecture une nouvelle section 'Philosophie de Développement Feature-First' incluant : principe de livraison rapide de valeur, focus sur la simplicité et l'itération, tests écrits après stabilisation des fonctionnalités, exemples concrets de workflow (implémenter -> tester manuellement -> itérer -> tests de régression), avantages de cette approche (vélocité, flexibilité, pragmatisme), et comment équilibrer qualité et rapidité de livraison.",
            "status": "pending",
            "testStrategy": "Vérifier que la nouvelle section est bien positionnée, qu'elle contient tous les éléments clés de la philosophie Feature-First, et que le ton est positif et pragmatique"
          },
          {
            "id": 3,
            "title": "Simplification des Commandes et Workflows CI/CD",
            "description": "Réviser les sections de commandes essentielles et CI/CD pour refléter un processus de développement plus simple et direct",
            "dependencies": [
              "11.2"
            ],
            "details": "Simplifier la section 'Commandes Essentielles' en gardant uniquement les commandes vraiment utiles au quotidien. Supprimer ou alléger la section CI/CD GitHub Actions en ne gardant que les workflows de base (build et release). Retirer les références aux hooks Git de pré-commit obligatoires. Simplifier le workflow Git en supprimant les conditions strictes de merge liées aux tests. Adapter la checklist pré-commit pour être plus pragmatique et moins contraignante.",
            "status": "pending",
            "testStrategy": "S'assurer que les commandes restantes sont toutes fonctionnelles et que le nouveau workflow est cohérent avec l'approche Feature-First"
          },
          {
            "id": 4,
            "title": "Mise à Jour des Versions et Dépendances Documentées",
            "description": "Actualiser toutes les versions de dépendances mentionnées dans la documentation pour refléter l'état actuel du projet",
            "dependencies": [
              "11.3"
            ],
            "details": "Mettre à jour les versions dans la section 'Stack Technique Obligatoire' : Flutter vers la dernière stable (3.32.6+), Dart correspondant, versions des packages principaux (Riverpod 2.6.1+, Freezed 2.5.7+, go_router 14.6.0+, Supabase dernière version). Vérifier que les versions correspondent à celles du pubspec.yaml actuel ou planifié. Ajouter une note sur la politique de mise à jour régulière des dépendances.",
            "status": "pending",
            "testStrategy": "Comparer les versions documentées avec celles du pubspec.yaml pour s'assurer de la cohérence"
          },
          {
            "id": 5,
            "title": "Révision du Document .taskmaster/CLAUDE.md",
            "description": "Adapter le document TaskMaster pour qu'il soit cohérent avec la nouvelle philosophie et supprimer les références TDD",
            "dependencies": [
              "11.4"
            ],
            "details": "Ouvrir .taskmaster/CLAUDE.md et vérifier s'il contient des références au TDD ou aux pratiques abandonnées. Adapter les exemples de workflow pour refléter l'approche Feature-First. S'assurer que les instructions d'utilisation de TaskMaster restent pertinentes. Ajouter si nécessaire des notes sur comment utiliser TaskMaster efficacement dans un contexte Feature-First. Vérifier la cohérence entre les deux documents CLAUDE.md.",
            "status": "pending",
            "testStrategy": "Relecture croisée des deux documents pour vérifier la cohérence du message et l'absence de contradictions"
          }
        ]
      },
      {
        "id": 12,
        "title": "Configuration d'un Environnement de Développement Optimisé",
        "description": "Configurer l'environnement de développement pour maximiser la productivité avec hot reload, shortcuts, et outils de debug",
        "details": "1. Configurer VS Code ou Android Studio :\n   - Installer/mettre à jour extensions Flutter et Dart\n   - Configurer les raccourcis pour hot reload\n   - Activer format on save\n2. Créer des snippets pour code boilerplate fréquent :\n   - Widgets Riverpod\n   - Modèles Freezed\n   - Appels Supabase courants\n3. Configurer les launch configurations :\n   - Mode debug avec variables d'environnement\n   - Mode release pour tests performance\n4. Installer Flutter DevTools\n5. Configurer un émulateur Android performant :\n   - API 34+\n   - Hardware acceleration activé\n   - Snapshot pour démarrage rapide\n6. Créer des scripts bash simples pour :\n   - Clean build : flutter clean && flutter pub get\n   - Generate : build_runner\n   - Quick run avec env vars\n7. Configurer .env.example avec les variables nécessaires",
        "testStrategy": "Lancer l'application en mode debug et vérifier que le hot reload fonctionne en moins de 2 secondes. DevTools doit se connecter correctement.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configuration de l'IDE et Extensions Flutter",
            "description": "Installer et configurer VS Code ou Android Studio avec les extensions Flutter/Dart optimales pour maximiser la productivité",
            "dependencies": [],
            "details": "1. Installer VS Code (recommandé) ou Android Studio selon préférence\n2. Installer les extensions essentielles :\n   - Flutter (Dart-Code.flutter)\n   - Dart (Dart-Code.dart-code)\n   - Awesome Flutter Snippets\n   - Pubspec Assist\n   - Error Lens pour affichage inline des erreurs\n3. Configurer les settings.json :\n   - \"editor.formatOnSave\": true\n   - \"dart.flutterHotReloadOnSave\": \"always\"\n   - \"dart.previewFlutterUiGuides\": true\n   - \"editor.bracketPairColorization.enabled\": true\n4. Configurer les raccourcis clavier :\n   - Hot reload : Ctrl+S (automatique avec formatOnSave)\n   - Hot restart : Ctrl+Shift+R\n   - Wrap with widget : Alt+W\n5. Activer les Flutter UI Guides pour visualisation de l'arbre de widgets",
            "status": "pending",
            "testStrategy": "Ouvrir un fichier Dart, modifier du code et vérifier que Ctrl+S déclenche le formatage ET le hot reload en moins de 2 secondes"
          },
          {
            "id": 2,
            "title": "Création de Snippets Personnalisés pour Ojyx",
            "description": "Développer des snippets VS Code spécifiques au projet Ojyx pour accélérer l'écriture du code récurrent",
            "dependencies": [
              "12.1"
            ],
            "details": "1. Créer le fichier .vscode/ojyx.code-snippets dans le projet\n2. Implémenter les snippets essentiels :\n   - 'riverpod-provider' : Provider Riverpod avec syntaxe moderne @riverpod\n   - 'freezed-model' : Modèle Freezed avec json_serializable\n   - 'supabase-query' : Requête Supabase typique avec gestion d'erreur\n   - 'ojyx-screen' : Scaffold de base pour écran Ojyx\n   - 'ojyx-card-widget' : Widget de carte de jeu réutilisable\n3. Snippets spécifiques métier :\n   - 'game-state' : État de jeu Freezed avec grille 3x4\n   - 'player-action' : Action joueur avec validation\n   - 'realtime-listener' : Listener Supabase Realtime\n4. Documenter chaque snippet avec description et exemple d'usage\n5. Partager les snippets dans l'équipe via le repo",
            "status": "pending",
            "testStrategy": "Taper 'riverpod' dans un fichier .dart doit proposer le snippet, Tab doit l'insérer avec curseurs aux bons endroits"
          },
          {
            "id": 3,
            "title": "Configuration des Launch Configurations et DevTools",
            "description": "Mettre en place les configurations de lancement pour debug/release et installer Flutter DevTools",
            "dependencies": [
              "12.1"
            ],
            "details": "1. Créer .vscode/launch.json avec configurations :\n   - 'Ojyx Debug' : Mode debug avec variables d'environnement Supabase\n   - 'Ojyx Release' : Mode release pour tests performance\n   - 'Ojyx Profile' : Mode profile pour analyse performance\n2. Configurer les dart-define pour chaque mode :\n   - SUPABASE_URL et SUPABASE_ANON_KEY depuis .env\n   - DEBUG_MODE=true/false selon le mode\n3. Installer Flutter DevTools globalement :\n   - flutter pub global activate devtools\n   - Créer alias 'devtools' dans .bashrc/.zshrc\n4. Configurer l'ouverture automatique de DevTools en debug\n5. Activer les options DevTools utiles :\n   - Widget inspector\n   - Performance overlay en mode profile\n   - Network profiler pour debug Supabase",
            "status": "pending",
            "testStrategy": "F5 doit lancer l'app en debug avec les bonnes variables, DevTools doit s'ouvrir automatiquement et se connecter"
          },
          {
            "id": 4,
            "title": "Optimisation de l'Émulateur Android et Performance",
            "description": "Configurer un émulateur Android haute performance avec accélération matérielle et snapshots",
            "dependencies": [],
            "details": "1. Créer un AVD (Android Virtual Device) optimisé :\n   - Nom : 'Ojyx_Dev_Pixel_6'\n   - Device : Pixel 6 ou équivalent\n   - System Image : Android 14 (API 34) x86_64\n   - RAM : 4GB minimum\n   - VM Heap : 512MB\n2. Activer l'accélération matérielle :\n   - Vérifier Intel HAXM ou AMD Hypervisor\n   - GPU : Hardware - GLES 2.0\n   - Activer 'Cold Boot' : Fast\n3. Configurer les snapshots :\n   - Créer snapshot 'ojyx_clean' après installation\n   - Créer snapshot 'ojyx_logged_in' avec app installée\n4. Optimisations supplémentaires :\n   - Désactiver animations dans Developer Options\n   - Fixer la résolution à 1080x2400\n   - Activer 'Skip unmetered networks' pour performance\n5. Créer script 'start-emulator.sh' pour lancement rapide",
            "status": "pending",
            "testStrategy": "L'émulateur doit démarrer en moins de 10 secondes depuis un snapshot, hot reload < 1 seconde"
          },
          {
            "id": 5,
            "title": "Scripts d'Automatisation et Configuration Environnement",
            "description": "Créer des scripts bash et configurer l'environnement pour automatiser les tâches répétitives du développement Ojyx",
            "dependencies": [
              "12.3"
            ],
            "details": "1. Créer répertoire 'dev-scripts/' avec scripts essentiels :\n   - 'clean-build.sh' : flutter clean && flutter pub get && build_runner\n   - 'quick-run.sh' : Charge .env et lance avec dart-define\n   - 'generate.sh' : build_runner build --delete-conflicting-outputs\n   - 'reset-db.sh' : Reset Supabase local pour tests\n2. Créer '.env.example' documenté :\n   - SUPABASE_URL=https://xxx.supabase.co\n   - SUPABASE_ANON_KEY=xxx\n   - DEBUG_OVERLAY=true\n3. Script 'setup-dev.sh' pour nouveaux développeurs :\n   - Copie .env.example vers .env\n   - Installe dépendances\n   - Configure git hooks si nécessaire\n   - Lance émulateur et IDE\n4. Ajouter aliases dans .bashrc/.zshrc :\n   - alias ojyx-run='./dev-scripts/quick-run.sh'\n   - alias ojyx-clean='./dev-scripts/clean-build.sh'\n5. Documenter tous les scripts dans README_DEV.md",
            "status": "pending",
            "testStrategy": "Exécuter './dev-scripts/quick-run.sh' doit lancer l'app avec les bonnes variables en moins de 5 secondes"
          }
        ]
      },
      {
        "id": 13,
        "title": "Implémentation du Premier Feature - Écran d'Accueil",
        "description": "Développer rapidement l'écran d'accueil du jeu Ojyx en suivant l'approche Feature-First sans tests préalables",
        "details": "1. Créer la structure de base dans lib/features/home/ :\n   - presentation/screens/home_screen.dart\n   - presentation/widgets/ pour composants\n2. Implémenter l'UI directement :\n   - Logo/titre du jeu Ojyx\n   - Bouton 'Nouvelle Partie' principal\n   - Bouton 'Rejoindre une Partie'\n   - Bouton 'Règles du Jeu'\n   - Design simple mais attrayant\n3. Configurer la route dans go_router\n4. Connecter avec Riverpod pour l'état si nécessaire\n5. Ajouter les assets (logo, images) dans pubspec.yaml\n6. Implémenter la navigation vers les écrans futurs\n7. Tester manuellement sur émulateur\n8. Itérer rapidement sur le design\n9. Une fois satisfait, committer la feature complète",
        "testStrategy": "Test manuel : l'écran doit s'afficher correctement, les boutons doivent être cliquables, la navigation doit fonctionner. Tester sur différentes tailles d'écran.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer la structure de base du feature home et configurer les routes",
            "description": "Mettre en place l'architecture du feature home avec la structure Clean Architecture et configurer la route dans go_router",
            "dependencies": [],
            "details": "Créer les dossiers lib/features/home/presentation/screens/ et lib/features/home/presentation/widgets/. Créer le fichier home_screen.dart avec un scaffold de base. Ajouter la route HomeRoute dans lib/core/config/router_config.dart avec le path '/' pointant vers HomeScreen. S'assurer que le router est correctement configuré dans l'application principale.",
            "status": "pending",
            "testStrategy": "Vérifier manuellement que l'application se lance et affiche l'écran d'accueil vide. Tester que la route '/' charge bien le HomeScreen."
          },
          {
            "id": 2,
            "title": "Concevoir et implémenter l'interface utilisateur de l'écran d'accueil",
            "description": "Créer une UI attrayante avec le logo Ojyx, le titre du jeu et les trois boutons principaux en suivant les guidelines Material Design",
            "dependencies": [
              "13.1"
            ],
            "details": "Dans home_screen.dart, implémenter un design centré verticalement avec : un espace pour le logo/titre 'Ojyx' en haut (utiliser un Text stylisé pour commencer), trois boutons ElevatedButton espacés : 'Nouvelle Partie' (primary), 'Rejoindre une Partie', et 'Règles du Jeu'. Utiliser les couleurs du thème Material et ajouter des paddings appropriés. Implémenter un fond attrayant avec un gradient ou une couleur unie.",
            "status": "pending",
            "testStrategy": "Tester visuellement sur différentes tailles d'écran (téléphone, tablette). Vérifier que les boutons sont bien espacés et que le design est cohérent avec Material Design."
          },
          {
            "id": 3,
            "title": "Intégrer les assets visuels et configurer pubspec.yaml",
            "description": "Ajouter les ressources graphiques nécessaires (logo, images de fond) et les déclarer dans pubspec.yaml",
            "dependencies": [
              "13.2"
            ],
            "details": "Créer le dossier assets/images/ à la racine du projet. Créer un logo temporaire pour Ojyx (peut être un simple fichier PNG avec le texte stylisé). Ajouter la section flutter: assets: dans pubspec.yaml avec - assets/images/. Remplacer le Text du titre par un Image.asset() pointant vers le logo. Optionnellement, ajouter une image de fond pour l'écran d'accueil.",
            "status": "pending",
            "testStrategy": "Vérifier que les images s'affichent correctement après un hot reload. Tester que les assets sont bien chargés sur différentes densités d'écran."
          },
          {
            "id": 4,
            "title": "Implémenter la navigation et les callbacks des boutons",
            "description": "Ajouter les fonctions de navigation pour chaque bouton et préparer les routes futures",
            "dependencies": [
              "13.2",
              "13.3"
            ],
            "details": "Dans home_screen.dart, implémenter les onPressed pour chaque bouton. Pour 'Nouvelle Partie': utiliser context.push('/game/new') (route à créer plus tard). Pour 'Rejoindre une Partie': context.push('/game/join'). Pour 'Règles du Jeu': context.push('/rules'). Ajouter des routes placeholder dans router_config.dart qui retournent un Scaffold avec un message 'En construction'. Utiliser des méthodes séparées pour chaque action de navigation.",
            "status": "pending",
            "testStrategy": "Cliquer sur chaque bouton et vérifier la navigation vers les écrans placeholder. Tester le bouton retour pour revenir à l'accueil."
          },
          {
            "id": 5,
            "title": "Ajouter l'état Riverpod et finaliser l'écran",
            "description": "Intégrer Riverpod pour gérer l'état si nécessaire et peaufiner les détails de l'écran d'accueil",
            "dependencies": [
              "13.4"
            ],
            "details": "Créer un home_provider.dart dans presentation/providers/ si besoin d'état (ex: pour tracker les préférences utilisateur). Convertir HomeScreen en ConsumerWidget si utilisation de providers. Ajouter des animations subtiles (fade in des boutons, animation du logo). Implémenter un responsive design avec LayoutBuilder. Ajouter un footer avec la version de l'app. Nettoyer le code et s'assurer qu'il suit les conventions du projet.",
            "status": "pending",
            "testStrategy": "Tester l'écran sur plusieurs tailles et orientations. Vérifier que les animations sont fluides. S'assurer que l'état Riverpod fonctionne si implémenté."
          }
        ]
      },
      {
        "id": 14,
        "title": "Création des Tests de Régression pour l'Écran d'Accueil",
        "description": "Écrire des tests après coup pour verrouiller le comportement de l'écran d'accueil et prévenir les régressions futures",
        "details": "1. Créer test/features/home/home_screen_test.dart\n2. Écrire des tests de widget basiques :\n   - Test que l'écran se charge sans erreur\n   - Test présence du titre/logo\n   - Test présence des 3 boutons principaux\n   - Test que les taps sur boutons triggent navigation\n3. Utiliser testWidgets et find pour les assertions\n4. Mocker la navigation avec MockGoRouter si nécessaire\n5. Ne pas sur-tester : juste le comportement critique\n6. Exécuter les tests : 'flutter test'\n7. S'assurer qu'ils passent tous\n8. Ajouter au README une note sur l'exécution des tests de régression\n9. Committer les tests",
        "testStrategy": "Les tests doivent passer en vert. Introduire volontairement un bug dans l'UI pour vérifier que les tests le détectent, puis le corriger.",
        "priority": "medium",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer la structure de test et configurer l'environnement",
            "description": "Créer le fichier de test home_screen_test.dart avec les imports nécessaires et la configuration de base pour les tests de widgets",
            "dependencies": [],
            "details": "1. Créer le fichier test/features/home/home_screen_test.dart\n2. Ajouter les imports essentiels : flutter_test, le widget HomeScreen, et les dépendances nécessaires\n3. Configurer le setUp et tearDown si nécessaire\n4. Créer un helper pour wrapper les widgets avec les providers requis (GoRouter, Riverpod)\n5. Préparer la structure de base avec un groupe de tests 'HomeScreen Tests'",
            "status": "pending",
            "testStrategy": "Vérifier que le fichier est créé au bon endroit et que les imports se résolvent correctement sans erreur"
          },
          {
            "id": 2,
            "title": "Implémenter les tests de rendu et présence des éléments UI",
            "description": "Écrire les tests vérifiant que l'écran se charge correctement et que tous les éléments visuels principaux sont présents",
            "dependencies": [
              "14.1"
            ],
            "details": "1. Test 'should render without error' : vérifier que HomeScreen se construit sans exception\n2. Test 'should display app title/logo' : utiliser find.text ou find.byKey pour vérifier la présence du titre\n3. Test 'should display three main buttons' : vérifier la présence des boutons 'Créer une partie', 'Rejoindre', et 'Comment jouer'\n4. Utiliser testWidgets avec pump() pour attendre le rendu complet\n5. Ajouter des assertions claires avec expect() pour chaque élément",
            "status": "pending",
            "testStrategy": "Exécuter chaque test individuellement pour s'assurer qu'ils détectent bien l'absence d'un élément quand on le commente temporairement dans le code"
          },
          {
            "id": 3,
            "title": "Créer les mocks et tests de navigation",
            "description": "Configurer MockGoRouter et implémenter les tests vérifiant que les boutons déclenchent les bonnes navigations",
            "dependencies": [
              "14.2"
            ],
            "details": "1. Créer ou configurer MockGoRouter pour intercepter les appels de navigation\n2. Test 'should navigate to create game on button tap' : simuler tap sur 'Créer une partie'\n3. Test 'should navigate to join game on button tap' : simuler tap sur 'Rejoindre'\n4. Test 'should navigate to how to play on button tap' : simuler tap sur 'Comment jouer'\n5. Vérifier que go() ou push() est appelé avec la bonne route\n6. Utiliser tester.tap() et pumpAndSettle() pour les interactions",
            "status": "pending",
            "testStrategy": "Introduire volontairement une mauvaise route dans le code pour vérifier que le test échoue, puis corriger"
          },
          {
            "id": 4,
            "title": "Valider et optimiser la suite de tests",
            "description": "Exécuter tous les tests ensemble, vérifier leur fiabilité et optimiser leur performance",
            "dependencies": [
              "14.3"
            ],
            "details": "1. Exécuter 'flutter test test/features/home/home_screen_test.dart' pour valider tous les tests\n2. Vérifier qu'il n'y a pas de tests flaky (qui échouent aléatoirement)\n3. Optimiser les tests en factorisant le code commun dans des fonctions helper\n4. S'assurer que les tests sont indépendants (peuvent s'exécuter dans n'importe quel ordre)\n5. Vérifier le temps d'exécution et optimiser si nécessaire\n6. Ajouter des commentaires pour clarifier l'intention de chaque test",
            "status": "pending",
            "testStrategy": "Exécuter les tests plusieurs fois de suite et dans un ordre aléatoire pour garantir leur stabilité"
          },
          {
            "id": 5,
            "title": "Documenter et intégrer les tests au workflow",
            "description": "Ajouter la documentation nécessaire et s'assurer que les tests sont intégrés au processus de développement",
            "dependencies": [
              "14.4"
            ],
            "details": "1. Ajouter une section 'Tests de régression' dans le README.md\n2. Documenter la commande pour exécuter les tests : 'flutter test'\n3. Expliquer brièvement le but des tests de régression pour l'écran d'accueil\n4. Créer un commit avec message descriptif : 'test: add regression tests for home screen'\n5. Vérifier que les tests passent une dernière fois avant le commit\n6. S'assurer que .gitignore n'exclut pas les nouveaux fichiers de test",
            "status": "pending",
            "testStrategy": "Faire un clone du repo après commit et vérifier que les tests s'exécutent correctement sur une installation fraîche"
          }
        ]
      },
      {
        "id": 15,
        "title": "Documentation du Nouveau Workflow de Développement",
        "description": "Créer une documentation claire et concise expliquant le nouveau processus Feature-First pour les futurs développeurs",
        "details": "1. Créer docs/DEVELOPMENT_WORKFLOW.md\n2. Documenter le processus Feature-First :\n   - Étape 1 : Implémenter la fonctionnalité directement\n   - Étape 2 : Tester manuellement\n   - Étape 3 : Itérer jusqu'à satisfaction\n   - Étape 4 : Écrire tests de régression\n   - Étape 5 : Committer\n3. Ajouter des exemples concrets\n4. Lister les anti-patterns à éviter :\n   - Ne pas écrire de tests avant le code\n   - Ne pas sur-engineer\n   - Ne pas créer d'abstractions prématurées\n5. Expliquer quand refactorer (sessions dédiées)\n6. Garder le document court (2-3 pages max)\n7. Ajouter un quickstart pour nouveaux devs\n8. Référencer ce document dans README.md",
        "testStrategy": "Faire relire le document par un tiers pour s'assurer qu'il est clair et actionnable. Le workflow doit pouvoir être suivi par un nouveau développeur.",
        "priority": "low",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer la structure et l'en-tête du document DEVELOPMENT_WORKFLOW.md",
            "description": "Initialiser le fichier de documentation avec une structure claire incluant titre, table des matières et introduction expliquant la philosophie Feature-First",
            "dependencies": [],
            "details": "Créer docs/DEVELOPMENT_WORKFLOW.md avec : 1) Titre principal 'Workflow de Développement Ojyx - Approche Feature-First', 2) Table des matières avec liens internes, 3) Introduction courte (5-10 lignes) expliquant pourquoi cette approche a été choisie (rapidité, pragmatisme, focus sur la valeur), 4) Mention que ce document remplace l'approche TDD précédente, 5) Structure avec sections principales : Vue d'ensemble, Processus étape par étape, Exemples, Anti-patterns, Refactoring",
            "status": "pending",
            "testStrategy": "Vérifier que le fichier est créé au bon endroit (docs/), que la structure est claire avec des titres markdown bien formatés, et que l'introduction capture l'essence de l'approche Feature-First"
          },
          {
            "id": 2,
            "title": "Documenter le processus Feature-First en 5 étapes avec explications détaillées",
            "description": "Rédiger la section principale détaillant chaque étape du processus de développement Feature-First avec des instructions claires et des conseils pratiques",
            "dependencies": [
              "15.1"
            ],
            "details": "Dans la section 'Processus Feature-First', documenter : 1) Étape 1 - Implémenter directement (focus sur le MVP fonctionnel, pas de sur-ingénierie), 2) Étape 2 - Tester manuellement (lancer l'app, vérifier visuellement, tester les interactions), 3) Étape 3 - Itérer rapidement (ajuster selon les retours, améliorer l'UX), 4) Étape 4 - Écrire tests de régression (uniquement après stabilisation, focus sur les cas critiques), 5) Étape 5 - Committer avec message descriptif. Chaque étape doit avoir 3-5 lignes d'explication avec des tips pratiques",
            "status": "pending",
            "testStrategy": "Relire pour s'assurer que chaque étape est actionnable et qu'un développeur junior pourrait suivre le processus sans ambiguïté"
          },
          {
            "id": 3,
            "title": "Ajouter des exemples concrets tirés du projet Ojyx",
            "description": "Illustrer le workflow avec 2-3 exemples réels de fonctionnalités qui pourraient être développées dans le jeu Ojyx",
            "dependencies": [
              "15.2"
            ],
            "details": "Créer section 'Exemples Pratiques' avec : 1) Exemple 1 - Création de l'écran d'accueil (boutons navigation, design simple, tests manuels visuels), 2) Exemple 2 - Système de cartes du jeu (affichage grille 3x4, interactions drag&drop, validation visuelle), 3) Exemple 3 - Intégration multijoueur (connexion Supabase, synchronisation temps réel, tests avec 2 devices). Pour chaque exemple, montrer comment les 5 étapes s'appliquent concrètement avec des snippets de code courts si pertinent",
            "status": "pending",
            "testStrategy": "Vérifier que les exemples sont spécifiques à Ojyx et non génériques, qu'ils illustrent bien différents aspects du développement (UI, logique métier, backend)"
          },
          {
            "id": 4,
            "title": "Documenter les anti-patterns et pièges à éviter",
            "description": "Lister clairement les pratiques à éviter dans l'approche Feature-First avec explications des conséquences négatives",
            "dependencies": [
              "15.3"
            ],
            "details": "Section 'Anti-Patterns à Éviter' avec : 1) Ne pas écrire de tests avant le code (ralentit l'itération initiale), 2) Sur-ingénierie prématurée (YAGNI - You Ain't Gonna Need It), 3) Créer des abstractions trop tôt (attendre de voir les patterns émerger), 4) Perfectionnisme sur le premier jet (mieux vaut fonctionnel que parfait), 5) Ignorer complètement les tests (ils restent importants pour la régression), 6) Committer du code cassé (toujours vérifier que ça compile). Pour chaque anti-pattern, expliquer brièvement pourquoi c'est problématique (1-2 lignes)",
            "status": "pending",
            "testStrategy": "S'assurer que chaque anti-pattern a une justification claire et que la liste couvre les erreurs les plus courantes observées"
          },
          {
            "id": 5,
            "title": "Créer le quickstart, ajouter la référence dans README et finaliser le document",
            "description": "Rédiger une section quickstart concise, expliquer quand refactorer, puis intégrer la documentation dans le projet",
            "dependencies": [
              "15.4"
            ],
            "details": "1) Section 'Quickstart pour Nouveaux Développeurs' avec checklist : cloner le repo, lire ce doc, choisir une tâche dans TaskMaster, suivre les 5 étapes, demander une review. 2) Section 'Quand Refactorer' : uniquement en sessions dédiées, après 3-4 features similaires, quand la dette technique devient bloquante. 3) Garder le document sous 3 pages (vérifier la longueur). 4) Ajouter dans README.md une section 'Workflow de Développement' avec lien vers docs/DEVELOPMENT_WORKFLOW.md. 5) Relecture finale pour cohérence et clarté",
            "status": "pending",
            "testStrategy": "Faire relire par un tiers non familier avec le projet pour valider que le quickstart est suffisant pour démarrer. Vérifier que le lien dans README fonctionne"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-25T14:39:35.802Z",
      "updated": "2025-07-27T08:27:42.477Z",
      "description": "Tasks for master context"
    }
  }
}