{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Audit et Analyse des Dépendances",
        "description": "Analyser toutes les dépendances actuelles du projet, identifier les versions obsolètes et planifier la stratégie de mise à jour en respectant les contraintes de compatibilité",
        "details": "1. Exécuter `flutter pub outdated` pour obtenir la liste complète des dépendances obsolètes\n2. Créer un tableau de mapping avec les versions actuelles vs cibles\n3. Analyser les breaking changes pour chaque dépendance majeure:\n   - Flutter SDK: vérifier la migration vers Flutter 3.24+\n   - Riverpod: étudier la migration de 2.x vers 3.x (si applicable)\n   - go_router: vérifier les changements de API depuis la version actuelle\n   - freezed: s'assurer de la compatibilité avec build_runner 2.4+\n   - supabase_flutter: vérifier la compatibilité avec les autres dépendances\n4. Créer un document de stratégie de migration groupant les dépendances par ordre de criticité\n5. Identifier les dépendances transitives pouvant causer des conflits\n6. Planifier l'ordre de mise à jour optimal pour minimiser les risques",
        "testStrategy": "1. Créer des tests de régression pour chaque fonctionnalité critique avant la mise à jour\n2. Écrire des tests d'intégration vérifiant le comportement des dépendances clés (Riverpod providers, go_router navigation, Supabase queries)\n3. Mettre en place des tests de smoke pour valider que l'application démarre correctement après chaque mise à jour\n4. Créer des tests unitaires pour les adapters/wrappers autour des dépendances externes\n5. Utiliser le coverage report pour s'assurer d'une couverture minimale de 80% sur les zones impactées",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyser les dépendances actuelles et créer un rapport d'obsolescence",
            "description": "Exécuter flutter pub outdated et analyser systématiquement toutes les dépendances pour identifier les versions obsolètes, créer un tableau comparatif et prioriser les mises à jour",
            "dependencies": [],
            "details": "1. Exécuter `flutter pub outdated --json` pour obtenir les données structurées\n2. Parser la sortie JSON et créer un tableau avec colonnes: Package, Version actuelle, Version résolvable, Version latest, Type (direct/transitive)\n3. Classifier les dépendances par catégorie: Core Flutter, État/Navigation, Backend/Services, Utilitaires, Dev dependencies\n4. Identifier les dépendances critiques nécessitant une attention particulière (Riverpod, go_router, Supabase)\n5. Calculer l'écart de version pour chaque package (patch/minor/major)\n6. Générer un rapport markdown structuré dans .taskmaster/reports/dependency-audit.md\n<info added on 2025-07-25T15:09:50.900Z>\n**Résultats de l'analyse effectuée:**\n\nLe rapport d'obsolescence a été créé avec succès dans `.taskmaster/reports/dependency-audit.md`. L'analyse révèle 28 packages obsolètes au total, dont 3 dépendances directes critiques nécessitant des mises à jour majeures : freezed_annotation (passage de 2.x à 3.x), go_router (14.x à 16.x) et sentry_flutter. 5 dépendances de développement sont également obsolètes. Une contrainte importante identifiée : le pubspec.yaml spécifie Dart SDK ^3.8.1 alors que Flutter 3.32.6 utilise Dart 3.32.0, créant une incompatibilité. Les breaking changes majeurs dans freezed et go_router nécessitent une attention particulière et une migration par phases. Le risque global est évalué comme élevé, confirmant la nécessité d'une approche prudente et méthodique pour les mises à jour.\n</info added on 2025-07-25T15:09:50.900Z>",
            "status": "done",
            "testStrategy": "1. Créer un script de test vérifiant que toutes les dépendances du pubspec.yaml sont analysées\n2. Valider le format du rapport généré avec des tests unitaires\n3. Vérifier que les classifications de dépendances sont correctes"
          },
          {
            "id": 2,
            "title": "Analyser les breaking changes et créer une matrice de compatibilité",
            "description": "Étudier en profondeur les changelogs et migration guides de chaque dépendance majeure pour identifier les breaking changes et créer une matrice de compatibilité inter-dépendances",
            "dependencies": [
              "1.1"
            ],
            "details": "1. Pour chaque dépendance majeure, consulter:\n   - Changelog officiel sur pub.dev\n   - Migration guides sur GitHub\n   - Issues connues et solutions\n2. Créer une matrice de compatibilité:\n   - Riverpod 2.x → 3.x: impact sur StateNotifier, syntaxe des providers\n   - go_router: changements d'API, nouvelles fonctionnalités\n   - freezed/json_serializable: compatibilité avec build_runner\n   - supabase_flutter: changements Realtime, Auth API\n3. Identifier les incompatibilités potentielles entre packages\n4. Documenter les modifications de code requises pour chaque breaking change\n5. Créer un fichier .taskmaster/docs/breaking-changes-analysis.md\n<info added on 2025-07-25T15:16:25.803Z>\nAnalyse des breaking changes complétée. Deux documents créés :\n1. breaking-changes-analysis.md : Analyse détaillée des changements majeurs pour freezed (syntaxe abstract/sealed, suppression when/map), go_router (URLs case-sensitive), flutter_lints (nouvelles règles), et sentry_flutter (API mutable, config Android)\n2. compatibility-matrix.md : Matrice complète de compatibilité inter-dépendances\n\nRésultats clés :\n- Conflit identifié : freezed 3.x requiert analyzer ^8.0.0 mais build_runner 2.6.0 utilise ^7.6.0 (solution : dependency_overrides)\n- SDK minimum global : Dart 3.8.0 et Flutter 3.32.0 (imposés par flutter_lints 6.0.0)\n- Temps estimé total : 20-36 heures de travail\n- Ordre optimal : SDK/Linting → Build Tools → Freezed → Navigation → Services\n</info added on 2025-07-25T15:16:25.803Z>",
            "status": "done",
            "testStrategy": "1. Vérifier que chaque dépendance majeure a une section dans l'analyse\n2. Valider que les incompatibilités identifiées sont testables\n3. S'assurer que chaque breaking change a une stratégie de migration associée"
          },
          {
            "id": 3,
            "title": "Créer une stratégie de migration par ordre de priorité",
            "description": "Développer un plan de migration détaillé organisant les dépendances par ordre optimal de mise à jour pour minimiser les risques et les conflits",
            "dependencies": [
              "1.1",
              "1.2"
            ],
            "details": "1. Définir les critères de priorisation:\n   - Criticité pour l'application (Core > Features > Dev)\n   - Nombre de dépendances transitives impactées\n   - Complexité des breaking changes\n   - Risque de régression\n2. Créer les groupes de migration:\n   - Phase 1: Flutter SDK, Dart SDK, linters\n   - Phase 2: build_runner, freezed, json_serializable\n   - Phase 3: Riverpod et packages associés\n   - Phase 4: go_router et navigation\n   - Phase 5: Supabase, Sentry, utilitaires\n3. Pour chaque phase, définir:\n   - Ordre exact des packages\n   - Tests de validation requis\n   - Points de rollback\n4. Documenter dans .taskmaster/docs/migration-strategy.md\n<info added on 2025-07-25T16:50:23.630Z>\nStratégie complétée avec succès ! Documents créés dans .taskmaster/docs/ :\n\n**migration-strategy.md** - Plan détaillé en 6 phases (0-6) avec approche TDD stricte\n- Phase 0 : Préparation et sauvegarde complète (1-2h)\n- Phase 1 : SDK Flutter/Dart et environnement (2-3h)\n- Phase 2 : Linting et analyse statique (3-4h)\n- Phase 3 : Build tools (build_runner, json_serializable) (2-3h)\n- Phase 4 : Freezed - PHASE CRITIQUE avec régénération complète (8-12h)\n- Phase 5 : Navigation go_router avec tests exhaustifs (4-6h)\n- Phase 6 : Services externes Sentry/Supabase (4-6h)\n\n**rollback-plan.md** - Procédures de rollback granulaires pour chaque phase\n- Scripts de rollback automatisés (5-60 min selon la phase)\n- Points de sauvegarde git avec tags versionnés\n- Procédures de validation post-rollback\n- Gestion des états partiels et recovery\n\nDurée totale estimée : 30-40 heures réparties sur 5-6 jours\nChaque phase inclut : critères Go/No-Go stricts, scripts de validation automatisés, tests de régression, et commits atomiques permettant un rollback chirurgical si nécessaire.\n</info added on 2025-07-25T16:50:23.630Z>",
            "status": "done",
            "testStrategy": "1. Valider que chaque dépendance est assignée à une phase unique\n2. Vérifier que l'ordre respecte les dépendances transitives\n3. S'assurer que chaque phase a des critères de succès mesurables"
          },
          {
            "id": 4,
            "title": "Identifier et résoudre les conflits de dépendances transitives",
            "description": "Analyser en profondeur l'arbre de dépendances pour identifier les conflits potentiels et développer des stratégies de résolution",
            "dependencies": [
              "1.2",
              "1.3"
            ],
            "details": "1. Exécuter `flutter pub deps --style=tree` pour visualiser l'arbre complet\n2. Utiliser `flutter pub deps --json` pour analyse programmatique\n3. Identifier les conflits potentiels:\n   - Versions incompatibles demandées par différents packages\n   - Dépendances transitives obsolètes\n   - Packages en conflit avec les contraintes SDK\n4. Pour chaque conflit identifié:\n   - Documenter les packages impliqués\n   - Proposer des solutions (dependency_overrides, versions intermédiaires)\n   - Évaluer l'impact sur la stabilité\n5. Créer un script de validation des résolutions\n6. Documenter dans .taskmaster/docs/dependency-conflicts.md\n<info added on 2025-07-25T17:24:54.572Z>\nAnalyse des conflits de dépendances transitives complétée avec succès. Un seul conflit critique détecté entre analyzer 7.6.0 (requis par la version actuelle) et analyzer 8.0.0 (requis par freezed 3.x). Solution implémentée via dependency_overrides pour analyzer et _fe_analyzer_shared. Outils de validation créés : dependency-conflicts.md contenant l'analyse détaillée des conflits et solutions, check-conflicts.sh pour la détection automatique et continue des conflits transitifs, et dependency_overrides.yaml comme template de configuration. Le script check-conflicts.sh vérifie automatiquement les versions multiples, simule les mises à jour et teste les overrides nécessaires. Aucun blocage insurmontable identifié pour la migration, tous les autres packages s'alignent correctement sans conflits majeurs.\n</info added on 2025-07-25T17:24:54.572Z>",
            "status": "done",
            "testStrategy": "1. Créer des tests vérifiant qu'aucun conflit n'existe après résolution\n2. Valider que les dependency_overrides sont minimaux et justifiés\n3. Tester la résolution avec `flutter pub get --dry-run`"
          },
          {
            "id": 5,
            "title": "Créer un plan de test et de validation complet",
            "description": "Développer une suite de tests complète pour valider chaque étape de la migration et garantir la stabilité du projet tout au long du processus",
            "dependencies": [
              "1.3",
              "1.4"
            ],
            "details": "1. Créer une baseline de tests avant migration:\n   - Capturer l'état actuel avec des snapshots\n   - Documenter les comportements critiques\n   - Mesurer les performances actuelles\n2. Développer des tests par catégorie:\n   - Tests unitaires pour chaque provider Riverpod\n   - Tests d'intégration pour la navigation go_router\n   - Tests de contrat pour les APIs Supabase\n   - Tests E2E pour les parcours utilisateur\n3. Créer des scripts de validation automatisés:\n   - Pre-migration: validation de l'état initial\n   - Post-migration par phase: tests de non-régression\n   - Final: validation complète avec coverage\n4. Définir les métriques de succès:\n   - Coverage minimum maintenu à 80%\n   - Temps de build < baseline + 10%\n   - Zero regression sur les tests existants\n5. Documenter dans .taskmaster/docs/test-validation-plan.md\n<info added on 2025-07-25T17:42:47.103Z>\nPlan de test et validation complété avec succès. Le plan exhaustif a été créé et documenté dans .taskmaster/docs/test-validation-plan.md. Les scripts de validation automatisés ont été développés :\n- capture-baseline.sh pour capturer les métriques de référence avant migration\n- validate-phase.sh pour validation automatique après chaque phase\n- compare-metrics.sh pour comparaison des métriques avant/après\n\nUn template de test spécialisé freezed_migration_test_template.dart a été créé pour standardiser les tests de migration Freezed.\n\nPoints clés de l'implémentation :\n- 122 fichiers de tests existants identifiés nécessitant validation\n- Approche TDD stricte : tests écrits AVANT chaque modification de code\n- Validation automatisée intégrée à chaque étape du processus\n- Métriques mesurables avec baseline de référence (coverage ≥80%, 0 régressions)\n- Temps de test estimé : 30-45 minutes par phase de migration\n\nLe plan couvre toutes les phases de migration : SDK, linting, génération de code, Freezed, navigation et services backend. Chaque phase dispose de sa propre checklist de validation et de tests spécifiques adaptés aux changements attendus.\n</info added on 2025-07-25T17:42:47.103Z>",
            "status": "done",
            "testStrategy": "1. Valider que chaque catégorie de dépendance a des tests dédiés\n2. Vérifier que les scripts de validation sont exécutables et idempotents\n3. S'assurer que les métriques sont mesurables et réalistes"
          }
        ]
      },
      {
        "id": 2,
        "title": "Mise à Jour Incrémentale des Dépendances Core",
        "description": "Mettre à jour les dépendances fondamentales (Flutter SDK, Dart SDK, et les packages de base) en suivant rigoureusement la méthodologie TDD",
        "details": "1. Commencer par la mise à jour du Flutter SDK vers la dernière version stable (3.24.x):\n   ```bash\n   flutter upgrade\n   flutter doctor -v\n   ```\n2. Mettre à jour les dépendances de base dans l'ordre suivant:\n   - flutter_lints: ^5.0.0\n   - build_runner: ^2.4.13\n   - freezed: ^2.5.7\n   - json_serializable: ^6.8.0\n3. Pour chaque dépendance:\n   a. Créer une branche dédiée (ex: `chore/update-freezed`)\n   b. Écrire des tests vérifiant le comportement actuel (Red phase)\n   c. Mettre à jour la dépendance dans pubspec.yaml\n   d. Exécuter `flutter pub get`\n   e. Lancer les tests et noter les échecs\n   f. Adapter le code pour faire passer les tests (Green phase)\n   g. Refactorer si nécessaire (Refactor phase)\n4. Régénérer le code avec build_runner après chaque mise à jour:\n   ```bash\n   flutter pub run build_runner build --delete-conflicting-outputs\n   ```\n5. Valider avec `flutter analyze` et `flutter test`",
        "testStrategy": "1. Avant chaque mise à jour, capturer l'état actuel avec des tests snapshot\n2. Écrire des tests de contrat pour chaque interface publique utilisée\n3. Créer des tests de régression spécifiques pour les fonctionnalités Freezed (immutabilité, copyWith, toJson/fromJson)\n4. Tester la génération de code avec build_runner dans la CI\n5. Vérifier que tous les tests existants passent après chaque mise à jour\n6. Mesurer et maintenir une couverture de code > 80%",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Mise à jour du Flutter SDK et validation de l'environnement",
            "description": "Mettre à jour Flutter vers la dernière version stable 3.24.x et valider l'environnement de développement complet",
            "dependencies": [],
            "details": "1. Créer une branche dédiée `chore/update-flutter-sdk`\n2. Écrire des tests validant la version actuelle du SDK et les configurations\n3. Exécuter la mise à jour:\n   ```bash\n   flutter upgrade\n   flutter doctor -v\n   ```\n4. Vérifier que tous les composants sont valides (Android toolchain, Chrome, VS Code)\n5. Lancer tous les tests existants pour détecter les régressions potentielles\n6. Documenter les changements de version dans un CHANGELOG temporaire",
            "status": "done",
            "testStrategy": "1. Créer des tests vérifiant les versions SDK avant/après\n2. Tests de smoke sur la compilation Android\n3. Vérifier que tous les tests existants passent toujours\n4. Tester la génération de code avec build_runner"
          },
          {
            "id": 2,
            "title": "Mise à jour de flutter_lints et configuration du linting",
            "description": "Mettre à jour flutter_lints vers ^5.0.0 en suivant rigoureusement le cycle TDD et adapter les règles de linting",
            "dependencies": [
              "2.1"
            ],
            "details": "1. Créer une branche `chore/update-flutter-lints`\n2. Écrire des tests capturant les warnings/erreurs actuels du linter\n3. Mettre à jour dans pubspec.yaml: flutter_lints: ^5.0.0\n4. Exécuter `flutter pub get`\n5. Lancer `flutter analyze` et capturer les nouvelles erreurs\n6. Corriger le code pour respecter les nouvelles règles lint une par une\n7. Adapter analysis_options.yaml si nécessaire pour les règles projet-spécifiques\n8. Valider avec `flutter analyze --no-fatal-infos`\n<info added on 2025-07-25T21:37:41.387Z>\n9. **Résultats de la mise à jour flutter_lints 5.0.0 → 6.0.0 :**\n   - Total des issues détectées initialement : 364\n   - Issues restantes après correction : 60 (réduction de 83.5%)\n   - Corrections automatiques appliquées : 218 fixes\n     * Imports non utilisés supprimés\n     * Ajout de `const` sur les constructeurs constants\n     * Conversion var → final pour les variables non réassignées\n   - **11 erreurs de compilation restantes à corriger manuellement :**\n     * Méthodes `withOpacity` appelées sur des couleurs nullables\n     * Types manquants dans les tests (inférence de type plus stricte)\n   - Tests de migration créés avec succès pour valider les changements\n</info added on 2025-07-25T21:37:41.387Z>",
            "status": "done",
            "testStrategy": "1. Script de test comparant les outputs de flutter analyze avant/après\n2. Tests unitaires vérifiant que le code respecte les conventions\n3. Tests de régression sur les fichiers critiques\n4. Validation que aucun warning n'est introduit"
          },
          {
            "id": 3,
            "title": "Mise à jour de build_runner et validation de la génération de code",
            "description": "Mettre à jour build_runner vers ^2.4.13 et s'assurer que toute la génération de code fonctionne correctement",
            "dependencies": [
              "2.2"
            ],
            "details": "1. Créer une branche `chore/update-build-runner`\n2. Écrire des tests vérifiant les fichiers générés actuels (.g.dart, .freezed.dart)\n3. Sauvegarder un snapshot des fichiers générés pour comparaison\n4. Mettre à jour dans pubspec.yaml: build_runner: ^2.4.13\n5. Exécuter `flutter pub get`\n6. Lancer `flutter pub run build_runner build --delete-conflicting-outputs`\n7. Comparer les fichiers générés avec les snapshots\n8. Adapter le code si des différences sont détectées\n9. Relancer tous les tests pour valider",
            "status": "pending",
            "testStrategy": "1. Tests de snapshot sur tous les fichiers .g.dart et .freezed.dart\n2. Tests unitaires sur les modèles sérialisables\n3. Tests d'intégration vérifiant la génération complète\n4. Validation que les imports et exports sont corrects"
          },
          {
            "id": 4,
            "title": "Mise à jour de freezed et adaptation des modèles",
            "description": "Mettre à jour freezed vers ^2.5.7 et adapter tous les modèles immutables du projet",
            "dependencies": [
              "2.3"
            ],
            "details": "1. Créer une branche `chore/update-freezed`\n2. Identifier tous les modèles Freezed: `find lib -name '*.dart' -exec grep -l '@freezed' {} \\;`\n3. Écrire des tests exhaustifs pour chaque modèle (copyWith, toJson, fromJson, equality)\n4. Mettre à jour dans pubspec.yaml: freezed: ^2.5.7\n5. Exécuter `flutter pub get`\n6. Régénérer avec `flutter pub run build_runner build --delete-conflicting-outputs`\n7. Lancer les tests et corriger les échecs un par un\n8. Vérifier l'immutabilité et les unions types\n9. Valider que tous les providers Riverpod utilisant ces modèles fonctionnent",
            "status": "pending",
            "testStrategy": "1. Tests unitaires pour chaque méthode générée (copyWith, equality, toJson)\n2. Tests de sérialisation/désérialisation JSON\n3. Tests d'immutabilité vérifiant qu'aucune mutation n'est possible\n4. Tests d'intégration avec les providers Riverpod"
          },
          {
            "id": 5,
            "title": "Mise à jour de json_serializable et validation finale",
            "description": "Mettre à jour json_serializable vers ^6.8.0 et effectuer une validation complète de toutes les dépendances core",
            "dependencies": [
              "2.4"
            ],
            "details": "1. Créer une branche `chore/update-json-serializable`\n2. Écrire des tests de sérialisation pour tous les modèles JSON\n3. Créer des fixtures JSON pour les tests\n4. Mettre à jour dans pubspec.yaml: json_serializable: ^6.8.0\n5. Exécuter `flutter pub get`\n6. Régénérer tout le code: `flutter pub run build_runner build --delete-conflicting-outputs`\n7. Lancer tous les tests de sérialisation\n8. Validation finale complète:\n   - `flutter analyze`\n   - `flutter test`\n   - `flutter test --coverage` (vérifier > 80%)\n9. Créer une PR consolidée avec toutes les mises à jour",
            "status": "pending",
            "testStrategy": "1. Tests de round-trip JSON (objet -> JSON -> objet)\n2. Tests avec données malformées pour vérifier la robustesse\n3. Tests de performance sur la sérialisation\n4. Suite de tests de régression complète du projet"
          }
        ]
      },
      {
        "id": 3,
        "title": "Mise à Jour des Dépendances de Gestion d'État et Navigation",
        "description": "Mettre à jour Riverpod, go_router et les packages associés en adaptant le code selon les breaking changes identifiés",
        "details": "1. Mise à jour de Riverpod et packages associés:\n   - flutter_riverpod: ^2.5.1 ou ^3.0.0 (selon disponibilité)\n   - riverpod_annotation: ^2.3.5\n   - hooks_riverpod: ^2.5.2 (si utilisé)\n2. Pour la migration Riverpod:\n   a. Identifier tous les providers existants avec `grep -r 'Provider\\|StateNotifier' lib/`\n   b. Écrire des tests pour chaque provider AVANT la mise à jour\n   c. Migrer vers la nouvelle syntaxe si nécessaire (Notifier au lieu de StateNotifier)\n   d. Adapter les ConsumerWidget et ConsumerStatefulWidget\n3. Mise à jour de go_router:\n   - go_router: ^14.6.0\n   - Vérifier les changements dans la syntaxe de déclaration des routes\n   - Adapter les guards et redirections si nécessaire\n4. Code d'exemple pour la migration Riverpod:\n   ```dart\n   // Ancien: StateNotifier\n   class GameStateNotifier extends StateNotifier<GameState> {}\n   \n   // Nouveau: Notifier\n   @riverpod\n   class GameState extends _$GameState {\n     @override\n     GameStateModel build() => GameStateModel.initial();\n   }\n   ```\n5. Valider toutes les navigations avec des tests d'intégration",
        "testStrategy": "1. Créer des tests unitaires pour chaque provider Riverpod vérifiant:\n   - L'état initial\n   - Les mutations d'état\n   - Les effets de bord (API calls)\n2. Écrire des tests d'intégration pour go_router:\n   - Navigation entre écrans\n   - Deep linking\n   - Guards et redirections\n3. Tester les interactions provider-widget avec des widget tests\n4. Vérifier la persistance d'état lors des hot reloads\n5. Créer des tests E2E pour les flux utilisateur critiques",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit et Préparation de la Migration Riverpod",
            "description": "Identifier tous les providers existants, analyser les breaking changes et créer les tests de régression avant la mise à jour",
            "dependencies": [],
            "details": "1. Exécuter `grep -r 'Provider\\|StateNotifier\\|StateProvider\\|FutureProvider\\|StreamProvider' lib/` pour lister tous les providers\n2. Créer un inventaire détaillé avec:\n   - Type de provider (StateNotifier, StateProvider, etc.)\n   - Dépendances entre providers\n   - Utilisation dans les widgets\n3. Analyser les breaking changes entre la version actuelle et la cible:\n   - Migration StateNotifier vers Notifier\n   - Changements dans la syntaxe des providers\n   - Nouvelles annotations avec riverpod_annotation\n4. Documenter la stratégie de migration pour chaque provider\n5. Créer des tests unitaires pour chaque provider existant vérifiant:\n   - État initial\n   - Toutes les mutations d'état\n   - Comportement des dépendances",
            "status": "pending",
            "testStrategy": "1. Écrire des tests unitaires pour 100% des providers existants\n2. Créer des tests d'intégration pour les chaînes de providers dépendants\n3. Utiliser ProviderContainer pour tester les providers isolément\n4. Vérifier les edge cases et états d'erreur\n5. Créer des snapshots de l'état actuel pour comparaison post-migration"
          },
          {
            "id": 2,
            "title": "Migration des Providers Riverpod vers la Nouvelle Syntaxe",
            "description": "Migrer progressivement tous les providers vers la syntaxe moderne avec @riverpod et Notifier",
            "dependencies": [
              "3.1"
            ],
            "details": "1. Configurer riverpod_annotation et build_runner:\n   ```yaml\n   dependencies:\n     flutter_riverpod: ^2.5.1\n     riverpod_annotation: ^2.3.5\n   dev_dependencies:\n     riverpod_generator: ^2.4.3\n   ```\n2. Migrer les StateNotifier vers Notifier:\n   ```dart\n   // Avant\n   class GameStateNotifier extends StateNotifier<GameState> {\n     GameStateNotifier() : super(GameState.initial());\n   }\n   \n   // Après\n   @riverpod\n   class GameState extends _$GameState {\n     @override\n     GameStateModel build() => GameStateModel.initial();\n   }\n   ```\n3. Adapter les providers simples avec les annotations\n4. Migrer les FutureProvider et StreamProvider\n5. Mettre à jour les références dans tous les ConsumerWidget",
            "status": "pending",
            "testStrategy": "1. Exécuter les tests existants après chaque migration de provider\n2. Vérifier que les tests passent toujours au vert\n3. Ajouter des tests pour les nouvelles fonctionnalités (auto-dispose, etc.)\n4. Tester les performances avec les nouveaux providers\n5. Valider l'absence de fuites mémoire"
          },
          {
            "id": 3,
            "title": "Audit et Préparation de la Migration go_router",
            "description": "Analyser la configuration actuelle de go_router, identifier les breaking changes et préparer la migration",
            "dependencies": [],
            "details": "1. Inventorier la configuration actuelle:\n   - Routes définies\n   - Guards et redirections\n   - Deep linking configuré\n   - Paramètres et query parameters\n2. Analyser les breaking changes vers go_router ^14.6.0:\n   - Changements dans GoRoute constructor\n   - Nouvelle syntaxe pour les redirections\n   - Modifications des guards\n   - Évolution du StatefulShellRoute\n3. Créer des tests d'intégration pour toutes les routes:\n   ```dart\n   testWidgets('Navigation vers écran de jeu', (tester) async {\n     // Test de navigation avec paramètres\n   });\n   ```\n4. Documenter les changements nécessaires dans router_config.dart\n5. Préparer les mocks pour les tests de navigation",
            "status": "pending",
            "testStrategy": "1. Créer des tests widget pour chaque route définie\n2. Tester les redirections et guards\n3. Vérifier le deep linking avec différents URLs\n4. Tester la navigation avec paramètres\n5. Valider le comportement du back button sur Android"
          },
          {
            "id": 4,
            "title": "Migration de go_router et Adaptation du Routing",
            "description": "Mettre à jour go_router vers la version 14.6.0 et adapter toute la configuration de navigation",
            "dependencies": [
              "3.3"
            ],
            "details": "1. Mettre à jour la dépendance dans pubspec.yaml:\n   ```yaml\n   go_router: ^14.6.0\n   ```\n2. Adapter la configuration dans router_config.dart:\n   - Migrer vers la nouvelle syntaxe des routes\n   - Mettre à jour les redirections avec la nouvelle API\n   - Adapter les guards si nécessaire\n3. Exemple de migration:\n   ```dart\n   // Avant\n   redirect: (state) => authCheck(state),\n   \n   // Après\n   redirect: (context, state) => authCheck(context, state),\n   ```\n4. Mettre à jour tous les appels de navigation dans l'app:\n   - context.go() / context.push()\n   - Paramètres et query parameters\n5. Vérifier la compatibilité avec les ConsumerWidget mis à jour",
            "status": "pending",
            "testStrategy": "1. Exécuter tous les tests de navigation créés précédemment\n2. Vérifier que toutes les routes fonctionnent correctement\n3. Tester les cas limites (routes invalides, paramètres manquants)\n4. Valider la persistance de l'état lors de la navigation\n5. Tester sur device physique Android"
          },
          {
            "id": 5,
            "title": "Tests d'Intégration Complets et Validation Finale",
            "description": "Valider l'intégration complète entre Riverpod et go_router, et assurer la stabilité de l'application",
            "dependencies": [
              "3.2",
              "3.4"
            ],
            "details": "1. Créer des tests d'intégration complets:\n   - Navigation déclenchant des changements d'état Riverpod\n   - Providers influençant la navigation (guards basés sur l'auth)\n   - Synchronisation état global et route\n2. Tester les scénarios complexes:\n   ```dart\n   test('Navigation avec état Riverpod', () async {\n     // Changer l'état auth\n     // Vérifier la redirection automatique\n     // Valider l'état après navigation\n   });\n   ```\n3. Vérifier la performance:\n   - Temps de navigation entre écrans\n   - Consommation mémoire des providers\n   - Rebuilds inutiles\n4. Tests de régression sur toutes les features\n5. Validation sur différentes versions d'Android",
            "status": "pending",
            "testStrategy": "1. Suite complète de tests E2E avec integration_test\n2. Tests de performance avec flutter_driver\n3. Monitoring des rebuilds avec debugPrint\n4. Tests manuels sur devices physiques\n5. Validation de la CI/CD avec les nouvelles dépendances"
          }
        ]
      },
      {
        "id": 4,
        "title": "Mise à Jour des Dépendances Backend et Utilitaires",
        "description": "Mettre à jour Supabase, Sentry et toutes les dépendances utilitaires en garantissant la compatibilité avec l'infrastructure existante",
        "details": "1. Mise à jour de Supabase:\n   - supabase_flutter: ^2.6.0\n   - Vérifier la compatibilité avec les Edge Functions existantes\n   - Adapter les queries Realtime si changements d'API\n2. Mise à jour de Sentry:\n   - sentry_flutter: ^8.10.0\n   - Configurer les nouvelles options de performance monitoring\n3. Autres dépendances utilitaires:\n   - flutter_dotenv: ^5.1.0\n   - path_provider: ^2.1.4\n   - shared_preferences: ^2.3.2\n   - connectivity_plus: ^6.0.5\n4. Configuration Supabase mise à jour:\n   ```dart\n   await Supabase.initialize(\n     url: dotenv.env['SUPABASE_URL']!,\n     anonKey: dotenv.env['SUPABASE_ANON_KEY']!,\n     authOptions: FlutterAuthClientOptions(\n       authFlowType: AuthFlowType.implicit,\n       autoRefreshToken: true,\n     ),\n   );\n   ```\n5. Vérifier la compatibilité des WebSockets pour le mode multijoueur\n6. Tester les mécanismes de reconnexion automatique",
        "testStrategy": "1. Créer des tests d'intégration mockant Supabase:\n   - Tests de requêtes (select, insert, update, delete)\n   - Tests Realtime avec des WebSocket mocks\n   - Tests d'authentification anonyme\n2. Vérifier l'intégration Sentry avec des tests de capture d'erreur\n3. Tester la gestion de la connectivité réseau\n4. Créer des tests de performance pour les opérations Supabase\n5. Valider le stockage local avec des tests unitaires",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit et Planification des Mises à Jour Backend",
            "description": "Analyser les versions actuelles de Supabase, Sentry et des utilitaires, identifier les breaking changes et créer un plan de migration détaillé",
            "dependencies": [],
            "details": "1. Analyser le pubspec.yaml actuel et documenter les versions utilisées\n2. Consulter les changelogs officiels:\n   - Supabase Flutter: https://github.com/supabase/supabase-flutter/releases\n   - Sentry Flutter: https://github.com/getsentry/sentry-dart/releases\n   - Autres dépendances utilitaires\n3. Identifier les breaking changes critiques:\n   - API Realtime Supabase (channels, broadcast)\n   - Options de configuration Sentry\n   - APIs dépréciées dans connectivity_plus\n4. Créer une matrice de compatibilité avec les versions cibles\n5. Documenter les modifications de code nécessaires pour chaque dépendance",
            "status": "pending",
            "testStrategy": "1. Créer des tests de snapshot capturant le comportement actuel des intégrations\n2. Écrire des tests unitaires pour toutes les fonctions utilisant Supabase et Sentry\n3. Documenter les comportements attendus avant migration"
          },
          {
            "id": 2,
            "title": "Mise à Jour et Configuration de Supabase Flutter",
            "description": "Migrer vers supabase_flutter ^2.6.0 en adaptant les queries Realtime et en vérifiant la compatibilité avec les Edge Functions",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Mise à jour de la dépendance:\n   ```yaml\n   supabase_flutter: ^2.6.0\n   ```\n2. Adapter l'initialisation Supabase avec les nouvelles options:\n   ```dart\n   await Supabase.initialize(\n     url: dotenv.env['SUPABASE_URL']!,\n     anonKey: dotenv.env['SUPABASE_ANON_KEY']!,\n     authOptions: FlutterAuthClientOptions(\n       authFlowType: AuthFlowType.implicit,\n       autoRefreshToken: true,\n     ),\n   );\n   ```\n3. Migration des queries Realtime:\n   - Adapter channel() au lieu de from().on()\n   - Utiliser broadcast() pour les événements temps réel\n   - Implémenter les nouveaux callbacks de reconnexion\n4. Vérifier la compatibilité avec les Edge Functions existantes\n5. Mettre à jour les intercepteurs et error handlers",
            "status": "pending",
            "testStrategy": "1. Tests d'intégration avec Supabase mocké:\n   - CRUD operations (select, insert, update, delete)\n   - Realtime subscriptions avec WebSocket mocks\n   - Authentification anonyme et gestion des tokens\n2. Tests de reconnexion automatique\n3. Tests de latence et timeout"
          },
          {
            "id": 3,
            "title": "Mise à Jour et Configuration de Sentry Flutter",
            "description": "Migrer vers sentry_flutter ^8.10.0 et configurer les nouvelles options de performance monitoring",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Mise à jour de la dépendance:\n   ```yaml\n   sentry_flutter: ^8.10.0\n   ```\n2. Adapter l'initialisation Sentry avec les nouvelles options:\n   ```dart\n   await SentryFlutter.init(\n     (options) {\n       options.dsn = dotenv.env['SENTRY_DSN'];\n       options.tracesSampleRate = 1.0;\n       options.profilesSampleRate = 1.0;\n       options.enableAutoPerformanceTracing = true;\n       options.enableUserInteractionTracing = true;\n       options.attachScreenshot = true;\n       options.attachViewHierarchy = true;\n     },\n   );\n   ```\n3. Configurer le performance monitoring:\n   - Transactions automatiques pour les routes\n   - Spans pour les opérations Supabase\n   - Breadcrumbs enrichis\n4. Implémenter les nouveaux hooks de capture d'erreur\n5. Configurer les environnements (dev, staging, prod)",
            "status": "pending",
            "testStrategy": "1. Tests unitaires de capture d'erreur\n2. Tests d'intégration vérifiant:\n   - Envoi des transactions\n   - Attachement des screenshots\n   - Performance metrics\n3. Tests de désactivation en mode debug"
          },
          {
            "id": 4,
            "title": "Mise à Jour des Dépendances Utilitaires",
            "description": "Mettre à jour flutter_dotenv, path_provider, shared_preferences et connectivity_plus en gérant les changements d'API",
            "dependencies": [
              "4.1"
            ],
            "details": "1. Mettre à jour les dépendances utilitaires:\n   ```yaml\n   flutter_dotenv: ^5.1.0\n   path_provider: ^2.1.4\n   shared_preferences: ^2.3.2\n   connectivity_plus: ^6.0.5\n   ```\n2. Adapter le code pour flutter_dotenv:\n   - Vérifier le chargement asynchrone\n   - Gérer les erreurs de fichier .env manquant\n3. Migration connectivity_plus:\n   - Utiliser les nouvelles énumérations ConnectivityResult\n   - Adapter les listeners de changement de connexion\n   - Implémenter la vérification de connexion Internet réelle\n4. Vérifier path_provider sur Android 14+:\n   - Permissions de stockage\n   - Scoped storage compliance\n5. Tester shared_preferences avec les nouvelles méthodes async",
            "status": "pending",
            "testStrategy": "1. Tests unitaires pour chaque utilitaire:\n   - Mock de flutter_dotenv\n   - Mock de connectivity_plus streams\n   - Tests de persistence shared_preferences\n2. Tests d'intégration cross-platform\n3. Tests de gestion d'erreur et fallback"
          },
          {
            "id": 5,
            "title": "Tests d'Intégration et Validation Complète",
            "description": "Exécuter une suite complète de tests d'intégration pour valider la compatibilité de toutes les mises à jour backend",
            "dependencies": [
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "1. Créer une suite de tests end-to-end:\n   - Initialisation complète de l'application\n   - Test du flow d'authentification anonyme Supabase\n   - Vérification des WebSockets Realtime\n   - Capture d'erreurs avec Sentry\n2. Tests de performance:\n   - Mesurer les temps d'initialisation\n   - Vérifier la consommation mémoire\n   - Tester la reconnexion après perte réseau\n3. Tests de régression:\n   - Vérifier toutes les fonctionnalités existantes\n   - Tester les edge cases identifiés\n4. Validation sur différents environnements:\n   - Android API 21, 26, 30, 34\n   - Mode release vs debug\n   - Avec/sans connexion Internet\n5. Documentation des résultats et ajustements finaux",
            "status": "pending",
            "testStrategy": "1. Suite de tests automatisés avec coverage > 80%\n2. Tests manuels sur devices physiques\n3. Monitoring des métriques Sentry en staging\n4. Tests de charge sur les connexions Realtime\n5. Validation des logs et error reporting"
          }
        ]
      },
      {
        "id": 5,
        "title": "Configuration et Résolution des Problèmes de Build Android",
        "description": "Configurer l'environnement de build Android, résoudre les erreurs Gradle et garantir une compilation fonctionnelle",
        "details": "1. Mise à jour de la configuration Android:\n   - android/gradle/wrapper/gradle-wrapper.properties: Gradle 8.5+\n   - android/build.gradle: \n     ```gradle\n     ext.kotlin_version = '1.9.25'\n     classpath 'com.android.tools.build:gradle:8.3.2'\n     ```\n   - android/app/build.gradle:\n     ```gradle\n     compileSdkVersion 34\n     minSdkVersion 21\n     targetSdkVersion 34\n     ```\n2. Résoudre les problèmes courants:\n   - Namespace obligatoire dans Android Gradle Plugin 8.0+\n   - Migration vers les nouvelles APIs Android\n   - Compatibilité avec androidx\n3. Configuration du build.gradle app:\n   ```gradle\n   android {\n     namespace 'com.example.ojyx'\n     compileSdkVersion flutter.compileSdkVersion\n     \n     defaultConfig {\n       applicationId 'com.example.ojyx'\n       minSdkVersion 21\n       targetSdkVersion flutter.targetSdkVersion\n       versionCode flutterVersionCode.toInteger()\n       versionName flutterVersionName\n       multiDexEnabled true\n     }\n   }\n   ```\n4. Nettoyer et reconstruire:\n   ```bash\n   flutter clean\n   cd android && ./gradlew clean\n   cd .. && flutter pub get\n   flutter build apk --debug\n   ```",
        "testStrategy": "1. Créer un script de build automatisé testant:\n   - Build debug APK\n   - Build release APK\n   - Build App Bundle\n2. Tester sur différentes versions d'Android (API 21, 26, 30, 34)\n3. Vérifier les permissions dans AndroidManifest.xml\n4. Tester l'installation et le lancement sur émulateur\n5. Valider la signature de l'APK pour le release\n6. Créer des tests de smoke post-installation",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Mise à jour et configuration des fichiers Gradle",
            "description": "Mettre à jour les fichiers de configuration Gradle pour Android avec les versions compatibles et résoudre les problèmes de namespace",
            "dependencies": [],
            "details": "1. Mettre à jour android/gradle/wrapper/gradle-wrapper.properties:\n   - distributionUrl=https://services.gradle.org/distributions/gradle-8.5-all.zip\n2. Modifier android/build.gradle:\n   ```gradle\n   buildscript {\n     ext.kotlin_version = '1.9.25'\n     repositories {\n       google()\n       mavenCentral()\n     }\n     dependencies {\n       classpath 'com.android.tools.build:gradle:8.3.2'\n       classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n     }\n   }\n   ```\n3. Ajouter le namespace obligatoire dans android/app/build.gradle:\n   ```gradle\n   android {\n     namespace 'com.example.ojyx'\n   }\n   ```\n4. Vérifier la compatibilité avec le plugin Android Gradle 8.0+",
            "status": "pending",
            "testStrategy": "1. Créer un script de validation Gradle:\n   - Vérifier la version de Gradle avec ./gradlew --version\n   - Tester la résolution des dépendances avec ./gradlew dependencies\n2. Écrire des tests unitaires vérifiant:\n   - La présence du namespace dans le fichier build.gradle\n   - Les versions correctes de Kotlin et AGP\n3. Valider que les tâches Gradle s'exécutent sans erreur"
          },
          {
            "id": 2,
            "title": "Configuration des SDK et options de compilation Android",
            "description": "Configurer les versions des SDK Android, les options de compilation et activer les fonctionnalités nécessaires comme MultiDex",
            "dependencies": [
              "5.1"
            ],
            "details": "1. Mettre à jour android/app/build.gradle avec les configurations SDK:\n   ```gradle\n   android {\n     compileSdkVersion 34\n     ndkVersion flutter.ndkVersion\n     \n     defaultConfig {\n       applicationId 'com.example.ojyx'\n       minSdkVersion 21\n       targetSdkVersion 34\n       versionCode flutterVersionCode.toInteger()\n       versionName flutterVersionName\n       multiDexEnabled true\n     }\n     \n     compileOptions {\n       sourceCompatibility JavaVersion.VERSION_17\n       targetCompatibility JavaVersion.VERSION_17\n     }\n     \n     kotlinOptions {\n       jvmTarget = '17'\n     }\n   }\n   ```\n2. Ajouter les dépendances androidx nécessaires:\n   ```gradle\n   dependencies {\n     implementation 'androidx.multidex:multidex:2.0.1'\n   }\n   ```\n3. Configurer le support des architectures:\n   ```gradle\n   android {\n     defaultConfig {\n       ndk {\n         abiFilters 'armeabi-v7a', 'arm64-v8a', 'x86_64'\n       }\n     }\n   }\n   ```",
            "status": "pending",
            "testStrategy": "1. Écrire des tests vérifiant la configuration SDK:\n   - Test que compileSdkVersion >= 34\n   - Test que minSdkVersion = 21\n   - Test que multiDexEnabled = true\n2. Créer des tests de build pour différentes architectures:\n   - Build pour arm64-v8a\n   - Build pour armeabi-v7a\n3. Tester la compatibilité Java 17 avec un test de compilation"
          },
          {
            "id": 3,
            "title": "Migration et résolution des APIs Android obsolètes",
            "description": "Identifier et migrer les APIs Android obsolètes, résoudre les problèmes de compatibilité avec AndroidX et les permissions",
            "dependencies": [
              "5.2"
            ],
            "details": "1. Vérifier et mettre à jour AndroidManifest.xml:\n   ```xml\n   <uses-permission android:name=\"android.permission.INTERNET\"/>\n   <application\n     android:name=\"${applicationName}\"\n     android:label=\"ojyx\"\n     android:icon=\"@mipmap/ic_launcher\"\n     android:usesCleartextTraffic=\"false\"\n     android:allowBackup=\"false\">\n   </application>\n   ```\n2. Migrer vers les nouvelles APIs Android:\n   - Remplacer les imports obsolètes android.support.* par androidx.*\n   - Utiliser WindowCompat pour la gestion des insets\n   - Migrer vers les nouvelles APIs de notification si utilisées\n3. Ajouter android.enableJetifier=true dans gradle.properties si nécessaire\n4. Résoudre les conflits de versions androidx:\n   ```gradle\n   configurations.all {\n     resolutionStrategy {\n       force 'androidx.core:core:1.12.0'\n       force 'androidx.lifecycle:lifecycle-runtime:2.7.0'\n     }\n   }\n   ```",
            "status": "pending",
            "testStrategy": "1. Créer des tests de lint Android:\n   - Vérifier l'absence d'APIs obsolètes\n   - Valider les imports androidx\n2. Écrire des tests d'intégration pour les permissions:\n   - Test de demande de permission Internet\n   - Test des paramètres de sécurité (cleartext traffic)\n3. Tester la compatibilité avec différentes versions d'Android (API 21, 26, 30, 34)"
          },
          {
            "id": 4,
            "title": "Optimisation et nettoyage du build Android",
            "description": "Nettoyer le projet, optimiser les paramètres de build et créer des scripts de build automatisés pour différents environnements",
            "dependencies": [
              "5.3"
            ],
            "details": "1. Créer un script de nettoyage complet clean_build.sh:\n   ```bash\n   #!/bin/bash\n   flutter clean\n   cd android\n   ./gradlew clean\n   rm -rf .gradle\n   cd ..\n   rm -rf build/\n   flutter pub get\n   cd android\n   ./gradlew build --refresh-dependencies\n   ```\n2. Optimiser les paramètres de build dans android/app/build.gradle:\n   ```gradle\n   android {\n     buildTypes {\n       release {\n         signingConfig signingConfigs.debug\n         minifyEnabled true\n         shrinkResources true\n         proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n       }\n       debug {\n         applicationIdSuffix \".debug\"\n         debuggable true\n       }\n     }\n     packagingOptions {\n       exclude 'META-INF/DEPENDENCIES'\n       exclude 'META-INF/LICENSE'\n       exclude 'META-INF/LICENSE.txt'\n     }\n   }\n   ```\n3. Configurer les flavors si nécessaire pour différents environnements\n4. Créer des tâches Gradle personnalisées pour automatiser les builds",
            "status": "pending",
            "testStrategy": "1. Tester les différents types de build:\n   - flutter build apk --debug\n   - flutter build apk --release\n   - flutter build appbundle --release\n2. Mesurer les performances de build:\n   - Temps de compilation\n   - Taille des APK générés\n   - Utilisation mémoire durant le build\n3. Valider l'optimisation ProGuard/R8 sur le build release"
          },
          {
            "id": 5,
            "title": "Validation finale et création de la documentation de build",
            "description": "Valider l'ensemble de la configuration Android, créer une documentation complète et établir des procédures de dépannage",
            "dependencies": [
              "5.4"
            ],
            "details": "1. Exécuter une validation complète:\n   ```bash\n   flutter doctor -v\n   cd android && ./gradlew tasks\n   ./gradlew assembleDebug --stacktrace\n   ./gradlew assembleRelease --stacktrace\n   ```\n2. Créer un fichier ANDROID_BUILD.md documentant:\n   - Configuration Gradle requise\n   - Versions des SDK et outils\n   - Procédures de résolution des erreurs courantes\n   - Scripts de build automatisés\n3. Établir une checklist de validation:\n   - [ ] Gradle 8.5+ configuré\n   - [ ] Namespace Android défini\n   - [ ] SDK 34 compilé avec succès\n   - [ ] MultiDex activé et fonctionnel\n   - [ ] Build debug et release réussis\n   - [ ] APK installable sur émulateur\n4. Créer des tests de régression pour prévenir les futurs problèmes de build\n5. Documenter les erreurs rencontrées et leurs solutions",
            "status": "pending",
            "testStrategy": "1. Créer une suite de tests de build automatisés:\n   - Test de build incrémental\n   - Test de build clean\n   - Test de build avec cache\n2. Valider sur différents environnements:\n   - Linux/Mac/Windows\n   - Différentes versions de JDK (17, 21)\n3. Tester l'installation et le lancement:\n   - Sur émulateur Android\n   - Sur device physique si disponible\n4. Vérifier la reproductibilité des builds"
          }
        ]
      },
      {
        "id": 6,
        "title": "Validation Finale et Configuration CI/CD",
        "description": "Valider l'ensemble des mises à jour, configurer la CI/CD pour maintenir la stabilité et documenter les changements",
        "details": "1. Validation complète du projet:\n   ```bash\n   flutter doctor -v\n   flutter analyze --no-fatal-infos\n   flutter test --coverage\n   flutter build apk --release\n   ```\n2. Mise à jour du workflow GitHub Actions:\n   ```yaml\n   - uses: actions/setup-java@v4\n     with:\n       java-version: '17'\n       distribution: 'temurin'\n   - uses: subosito/flutter-action@v2\n     with:\n       flutter-version: '3.24.x'\n       channel: 'stable'\n   ```\n3. Configuration des étapes CI:\n   - Cache des dépendances Pub et Gradle\n   - Analyse statique stricte\n   - Tests avec rapport de couverture\n   - Build APK de validation\n   - Upload des artifacts\n4. Création d'un CHANGELOG.md détaillant:\n   - Toutes les dépendances mises à jour\n   - Les breaking changes résolus\n   - Les adaptations de code effectuées\n5. Mise à jour de la documentation développeur\n6. Configuration des hooks pre-commit pour maintenir la qualité",
        "testStrategy": "1. Tests E2E sur l'application complète:\n   - Parcours utilisateur principal\n   - Création et jointure de partie\n   - Gameplay basique\n2. Tests de performance:\n   - Temps de démarrage\n   - Utilisation mémoire\n   - FPS durant le jeu\n3. Validation de la CI/CD:\n   - Déclencher manuellement tous les workflows\n   - Vérifier les temps de build\n   - Valider les artifacts générés\n4. Tests de régression sur toutes les fonctionnalités\n5. Validation finale avec un APK installé sur device physique",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Validation complète de l'environnement de développement",
            "description": "Exécuter une validation complète de l'environnement Flutter, analyser le code et générer un rapport de couverture de tests",
            "dependencies": [],
            "details": "Exécuter les commandes de validation dans l'ordre : flutter doctor -v pour vérifier l'environnement, flutter analyze --no-fatal-infos pour l'analyse statique, flutter test --coverage pour les tests avec couverture, et flutter build apk --release pour valider la compilation release. Documenter tous les problèmes détectés et les résoudre avant de passer aux étapes suivantes.",
            "status": "pending",
            "testStrategy": "Créer un script de validation automatisé qui exécute toutes les commandes et capture les sorties. Vérifier que flutter doctor ne retourne aucune erreur critique, que l'analyse statique passe sans warnings, que la couverture de tests atteint au minimum 80%, et que le build release se termine avec succès."
          },
          {
            "id": 2,
            "title": "Mise à jour du workflow GitHub Actions",
            "description": "Configurer et mettre à jour le fichier de workflow GitHub Actions avec les versions les plus récentes des actions et outils",
            "dependencies": [
              "6.1"
            ],
            "details": "Mettre à jour .github/workflows/ci.yml avec actions/setup-java@v4 (Java 17 Temurin), subosito/flutter-action@v2 (Flutter 3.24.x stable). Configurer le cache pour les dépendances Pub et Gradle. Ajouter les étapes d'analyse statique stricte, tests avec rapport de couverture, build APK de validation et upload des artifacts. Tester le workflow sur une branche de test.",
            "status": "pending",
            "testStrategy": "Créer une PR de test pour déclencher le workflow et vérifier que toutes les étapes s'exécutent correctement. Valider que le cache fonctionne (temps d'exécution réduit lors des runs suivants), que les artifacts sont correctement uploadés, et que les rapports de couverture sont générés."
          },
          {
            "id": 3,
            "title": "Configuration des hooks pre-commit et qualité du code",
            "description": "Mettre en place des hooks pre-commit pour maintenir automatiquement la qualité du code et respecter les standards TDD",
            "dependencies": [
              "6.1"
            ],
            "details": "Installer et configurer pre-commit avec des hooks pour : formatage automatique du code (dart format), analyse statique (flutter analyze), exécution des tests (flutter test), vérification des règles TDD (détection de tests commentés, vérification de la couverture minimale). Créer un script de validation qui bloque les commits non conformes.",
            "status": "pending",
            "testStrategy": "Tester les hooks en créant volontairement des violations (code mal formaté, tests commentés, coverage insuffisante) et vérifier que les commits sont bloqués. Valider que les hooks n'interfèrent pas avec un workflow de développement normal lorsque le code respecte les standards."
          },
          {
            "id": 4,
            "title": "Création du CHANGELOG.md détaillé",
            "description": "Documenter exhaustivement toutes les modifications, mises à jour de dépendances et breaking changes dans un CHANGELOG.md structuré",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Créer un CHANGELOG.md suivant le format Keep a Changelog. Documenter : toutes les dépendances mises à jour avec versions avant/après, les breaking changes identifiés et leurs résolutions, les adaptations de code effectuées, les nouvelles fonctionnalités ajoutées, les bugs corrigés. Organiser par versions et dates, avec des liens vers les commits et PRs pertinents.",
            "status": "pending",
            "testStrategy": "Vérifier que le changelog est complet en comparant avec l'historique git et les modifications de pubspec.yaml. Valider que chaque breaking change documenté correspond à une adaptation réelle dans le code. Tester que les liens vers les commits et PRs sont fonctionnels."
          },
          {
            "id": 5,
            "title": "Mise à jour de la documentation développeur et validation finale",
            "description": "Mettre à jour CLAUDE.md et toute la documentation technique, puis effectuer une validation complète du projet",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Mettre à jour CLAUDE.md avec les nouvelles versions de dépendances, commandes modifiées, et procédures mises à jour. Documenter les nouveaux hooks pre-commit et le workflow CI/CD. Effectuer une validation finale complète : builds sur différents environnements, tests E2E, vérification des performances (temps de démarrage, utilisation mémoire, FPS). Créer un guide de migration pour les futurs développeurs.",
            "status": "pending",
            "testStrategy": "Exécuter une suite de tests complète incluant : tests unitaires, tests d'intégration, tests E2E sur le parcours utilisateur principal (création/jointure de partie, gameplay), tests de performance avec métriques de référence. Valider que la documentation est à jour en suivant les procédures documentées sur un environnement propre."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-25T14:39:35.802Z",
      "updated": "2025-07-25T21:37:46.958Z",
      "description": "Tasks for master context"
    }
  }
}