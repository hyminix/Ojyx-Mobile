name: TDD Enforcement

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  tdd-compliance:
    name: TDD Compliance Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # N√©cessaire pour analyser l'historique git
      
      - name: Check for commented tests
        id: commented-tests
        run: |
          echo "Checking for commented tests..."
          
          # Patterns de tests comment√©s √† d√©tecter
          PATTERNS=(
            "//.*test\\("
            "/\\*.*test"
            "skip:\\s*true"
            "\\.skip\\("
            "xit\\("
            "xtest\\("
            "pending\\("
            "// describe\\("
            "// it\\("
            "// expect\\("
          )
          
          VIOLATIONS=""
          for pattern in "${PATTERNS[@]}"; do
            echo "Checking pattern: $pattern"
            MATCHES=$(grep -rn "$pattern" --include="*.dart" lib/ test/ 2>/dev/null || true)
            if [ ! -z "$MATCHES" ]; then
              VIOLATIONS="${VIOLATIONS}\\n\\n‚ùå Pattern '$pattern' found:\\n$MATCHES"
            fi
          done
          
          if [ ! -z "$VIOLATIONS" ]; then
            echo "::error::Tests comment√©s d√©tect√©s!"
            echo -e "VIOLATIONS TROUV√âES:$VIOLATIONS"
            exit 1
          fi
          
          echo "‚úÖ Aucun test comment√© d√©tect√©"
      
      - name: Check for test summary files
        id: test-summary
        run: |
          echo "Checking for test summary files..."
          
          # Recherche de fichiers contenant 'test_summary' ou similaire
          SUMMARY_FILES=$(find . -type f -name "*test*summary*" -o -name "*TEST*SUMMARY*" 2>/dev/null || true)
          
          if [ ! -z "$SUMMARY_FILES" ]; then
            echo "::error::Fichiers test summary interdits d√©tect√©s!"
            echo "Fichiers trouv√©s:"
            echo "$SUMMARY_FILES"
            exit 1
          fi
          
          echo "‚úÖ Aucun fichier test summary d√©tect√©"
      
      - name: Verify test-first approach
        id: test-first
        run: |
          echo "Verifying test-first approach..."
          
          # Pour chaque fichier .dart dans lib/ (sauf generated), v√©rifier qu'un test existe
          MISSING_TESTS=""
          
          # Exclure les fichiers g√©n√©r√©s et main.dart
          for file in $(find lib/ -name "*.dart" -not -path "*/generated/*" -not -path "*/*.g.dart" -not -path "*/*.freezed.dart" -not -name "main.dart"); do
            # Construire le chemin du test attendu
            TEST_FILE=$(echo "$file" | sed 's|^lib/|test/|' | sed 's|\.dart$|_test.dart|')
            
            if [ ! -f "$TEST_FILE" ]; then
              # V√©rifier aussi sans le suffixe _test (pour certains cas sp√©ciaux)
              ALT_TEST_FILE=$(echo "$file" | sed 's|^lib/|test/|')
              if [ ! -f "$ALT_TEST_FILE" ]; then
                MISSING_TESTS="${MISSING_TESTS}\\n‚ùå Pas de test pour: $file"
              fi
            fi
          done
          
          if [ ! -z "$MISSING_TESTS" ]; then
            echo "::error::Fichiers sans tests d√©tect√©s!"
            echo -e "FICHIERS SANS TESTS:$MISSING_TESTS"
            exit 1
          fi
          
          echo "‚úÖ Tous les fichiers ont des tests correspondants"
      
      - name: Check git history for test-first (PRAGMATIC)
        id: git-history
        run: |
          echo "Checking git history for test-first approach (PRAGMATIC MODE)..."
          
          # Obtenir les fichiers modifi√©s dans cette PR
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
            PR_TITLE="${{ github.event.pull_request.title }}"
            
            # ====================================================================
            # EXCEPTION TEMPORAIRE : PR de correction de conformit√© TDD
            # ====================================================================
            # Si c'est une PR de correction TDD (fix/phase3-tdd-compliance), on v√©rifie
            # seulement que tous les fichiers ont des tests, pas l'ordre de cr√©ation
            if [[ "$PR_TITLE" == *"TDD compliance"* ]] || [[ "$PR_TITLE" == *"phase3-tdd"* ]]; then
              echo "üîß PR de correction TDD d√©tect√©e - Mode de v√©rification all√©g√©"
              echo "   ‚Üí V√©rification que tous les fichiers ont des tests uniquement"
              
              ALL_CODE_FILES=$(git diff --name-only $BASE_SHA..$HEAD_SHA | grep "^lib/.*\\.dart$" | grep -v "\\.g\\.dart$" | grep -v "\\.freezed\\.dart$" || true)
              
              MISSING_TESTS=""
              for code_file in $ALL_CODE_FILES; do
                test_file=$(echo "$code_file" | sed 's|^lib/|test/|' | sed 's|\.dart$|_test.dart|')
                
                if [ ! -f "$test_file" ]; then
                  # V√©rifier aussi sans le suffixe _test
                  ALT_TEST_FILE=$(echo "$code_file" | sed 's|^lib/|test/|')
                  if [ ! -f "$ALT_TEST_FILE" ]; then
                    MISSING_TESTS="${MISSING_TESTS}\\n‚ùå Fichier sans test: $code_file"
                  fi
                fi
              done
              
              if [ ! -z "$MISSING_TESTS" ]; then
                echo "::error::Fichiers sans tests d√©tect√©s dans la PR de correction!"
                echo -e "FICHIERS SANS TESTS:$MISSING_TESTS"
                exit 1
              fi
              
              echo "‚úÖ Tous les fichiers ont des tests - PR de correction TDD accept√©e"
            else
              # ====================================================================
              # MODE STANDARD : Approche pragmatique pour le code existant
              # ====================================================================
              # 1. On r√©cup√®re TOUS les fichiers nouveaux dans la PR (pas juste ceux cr√©√©s)
              # 2. On v√©rifie s'ils existaient d√©j√† dans la branche de base
              # 3. Pour les vrais nouveaux fichiers : r√®gle stricte TDD
              # 4. Pour les fichiers existants modifi√©s : on v√©rifie juste qu'ils ont des tests
              
              # Obtenir tous les fichiers ajout√©s/modifi√©s dans la PR
              ALL_CODE_FILES=$(git diff --name-only $BASE_SHA..$HEAD_SHA | grep "^lib/.*\\.dart$" | grep -v "\\.g\\.dart$" | grep -v "\\.freezed\\.dart$" || true)
              
              VIOLATIONS=""
              for code_file in $ALL_CODE_FILES; do
                test_file=$(echo "$code_file" | sed 's|^lib/|test/|' | sed 's|\.dart$|_test.dart|')
                
                # V√©rifier si le fichier existait d√©j√† dans la branche de base
                if git ls-tree $BASE_SHA --name-only | grep -q "^$code_file$"; then
                  echo "üìù $code_file est un fichier EXISTANT modifi√©"
                  
                  # Pour les fichiers existants, on v√©rifie seulement qu'ils ont un test
                  if [ ! -f "$test_file" ]; then
                    # V√©rifier aussi sans le suffixe _test
                    ALT_TEST_FILE=$(echo "$code_file" | sed 's|^lib/|test/|')
                    if [ ! -f "$ALT_TEST_FILE" ]; then
                      VIOLATIONS="${VIOLATIONS}\\n‚ùå Fichier existant modifi√© sans test: $code_file"
                    fi
                  fi
                else
                  echo "üÜï $code_file est un NOUVEAU fichier"
                  
                  # Pour les nouveaux fichiers, appliquer la r√®gle stricte du test-first
                  if [ -f "$test_file" ]; then
                    # Obtenir la date de cr√©ation du fichier de code dans cette PR
                    CODE_DATE=$(git log --format="%at" --diff-filter=A $BASE_SHA..$HEAD_SHA -- "$code_file" | tail -1)
                    
                    # Obtenir la date de cr√©ation du fichier de test dans cette PR
                    TEST_DATE=$(git log --format="%at" --diff-filter=A $BASE_SHA..$HEAD_SHA -- "$test_file" | tail -1)
                    
                    # Si le code a √©t√© cr√©√© avant le test, c'est une violation
                    if [ ! -z "$CODE_DATE" ] && [ ! -z "$TEST_DATE" ] && [ "$CODE_DATE" -lt "$TEST_DATE" ]; then
                      VIOLATIONS="${VIOLATIONS}\\n‚ùå NOUVEAU code cr√©√© avant le test: $code_file"
                      VIOLATIONS="${VIOLATIONS}\\n   ‚ÑπÔ∏è  Pour les nouveaux fichiers, le test DOIT √™tre cr√©√© avant ou en m√™me temps que le code"
                    fi
                  else
                    VIOLATIONS="${VIOLATIONS}\\n‚ùå NOUVEAU fichier sans test: $code_file"
                  fi
                fi
              done
              
              if [ ! -z "$VIOLATIONS" ]; then
                echo "::error::Violations du principe TDD d√©tect√©es!"
                echo -e "VIOLATIONS:$VIOLATIONS"
                echo ""
                echo "üìã R√àGLES TDD PRAGMATIQUES:"
                echo "  - Pour les NOUVEAUX fichiers : Le test DOIT √™tre cr√©√© AVANT le code"
                echo "  - Pour les fichiers EXISTANTS : Ils doivent avoir des tests (peu importe l'ordre)"
                echo "  - Cette approche permet de travailler sur le code legacy tout en appliquant le TDD strict sur le nouveau code"
                exit 1
              fi
            fi
          fi
          
          echo "‚úÖ Principe TDD respect√© (mode pragmatique)"
      
      - name: Validate test content
        id: test-content
        run: |
          echo "Validating test content..."
          
          # V√©rifier que les fichiers de test contiennent r√©ellement des tests
          EMPTY_TESTS=""
          
          for test_file in $(find test/ -name "*_test.dart"); do
            # V√©rifier la pr√©sence de test() ou testWidgets()
            if ! grep -q -E "(test\\(|testWidgets\\(|group\\()" "$test_file"; then
              EMPTY_TESTS="${EMPTY_TESTS}\\n‚ùå Fichier de test sans tests r√©els: $test_file"
            fi
          done
          
          if [ ! -z "$EMPTY_TESTS" ]; then
            echo "::error::Fichiers de test vides ou invalides d√©tect√©s!"
            echo -e "FICHIERS INVALIDES:$EMPTY_TESTS"
            exit 1
          fi
          
          echo "‚úÖ Tous les fichiers de test contiennent des tests valides"
      
      - name: Check for skip or todo patterns
        id: skip-patterns
        run: |
          echo "Checking for skip or todo patterns in tests..."
          
          # Rechercher des patterns indiquant des tests incomplets
          SKIP_PATTERNS=(
            "TODO.*test"
            "FIXME.*test"
            "skip\\("
            "skipTest"
            "testWidgets.*skip"
            "test.*skip"
          )
          
          VIOLATIONS=""
          for pattern in "${SKIP_PATTERNS[@]}"; do
            MATCHES=$(grep -rn "$pattern" --include="*_test.dart" test/ 2>/dev/null || true)
            if [ ! -z "$MATCHES" ]; then
              VIOLATIONS="${VIOLATIONS}\\n\\n‚ùå Pattern '$pattern' found:\\n$MATCHES"
            fi
          done
          
          if [ ! -z "$VIOLATIONS" ]; then
            echo "::error::Tests incomplets ou skipp√©s d√©tect√©s!"
            echo -e "VIOLATIONS:$VIOLATIONS"
            exit 1
          fi
          
          echo "‚úÖ Aucun test incomplet d√©tect√©"
      
      - name: Generate compliance report
        if: always()
        run: |
          echo "## üìä TDD Compliance Report (Mode Pragmatique)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚ÑπÔ∏è Mode Pragmatique Activ√©" >> $GITHUB_STEP_SUMMARY
          echo "- **Nouveaux fichiers** : Test-first strict (test cr√©√© avant le code)" >> $GITHUB_STEP_SUMMARY
          echo "- **Fichiers existants** : Doivent avoir des tests (ordre non v√©rifi√©)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.commented-tests.outcome }}" == "success" ]; then
            echo "‚úÖ **Tests comment√©s**: Aucun d√©tect√©" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Tests comment√©s**: Violations d√©tect√©es" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.test-summary.outcome }}" == "success" ]; then
            echo "‚úÖ **Fichiers test summary**: Aucun d√©tect√©" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Fichiers test summary**: Violations d√©tect√©es" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.test-first.outcome }}" == "success" ]; then
            echo "‚úÖ **Tests pour tous les fichiers**: Valid√©" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Tests pour tous les fichiers**: Fichiers sans tests d√©tect√©s" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.git-history.outcome }}" == "success" ]; then
            echo "‚úÖ **Test-first (historique git)**: Respect√© (mode pragmatique)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Test-first (historique git)**: Violations d√©tect√©es" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.test-content.outcome }}" == "success" ]; then
            echo "‚úÖ **Contenu des tests**: Valide" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Contenu des tests**: Tests vides d√©tect√©s" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.skip-patterns.outcome }}" == "success" ]; then
            echo "‚úÖ **Tests incomplets**: Aucun d√©tect√©" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Tests incomplets**: Patterns skip/todo d√©tect√©s" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "‚ö†Ô∏è **Rappel**: Le TDD reste OBLIGATOIRE pour tout nouveau code." >> $GITHUB_STEP_SUMMARY

  close-pr-on-violation:
    name: Close PR on TDD Violation
    runs-on: ubuntu-latest
    needs: tdd-compliance
    if: failure() && github.event_name == 'pull_request'
    
    steps:
      - name: Close PR with violation message
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = context.issue.number;
            const violation_message = `‚ùå **PR ferm√©e automatiquement : Violation des r√®gles TDD d√©tect√©e.**
            
            Les checks TDD ont √©chou√©. Veuillez consulter les logs CI pour plus de d√©tails.
            
            **Actions requises :**
            1. Cr√©er une nouvelle branche
            2. Corriger TOUTES les violations TDD
            3. S'assurer que tous les tests sont √©crits AVANT le code (pour les nouveaux fichiers)
            4. S'assurer que tous les fichiers modifi√©s ont des tests
            5. Soumettre une nouvelle PR
            
            **R√®gles TDD (Mode Pragmatique) :**
            - ‚úÖ Pour les NOUVEAUX fichiers : √âcrire les tests AVANT le code
            - ‚úÖ Pour les fichiers EXISTANTS : Ils doivent avoir des tests (peu importe l'ordre)
            - ‚ùå Ne JAMAIS commenter ou d√©sactiver des tests
            - ‚ùå Ne JAMAIS cr√©er de fichiers "test_summary"
            - ‚úÖ TOUS les tests doivent passer (100%)
            - ‚úÖ Coverage minimum de 80%
            
            üìñ Consultez \`CLAUDE.md\` et \`GITHUB_BRANCH_PROTECTION.md\` pour les r√®gles compl√®tes.
            
            **Le TDD reste obligatoire pour tout nouveau code.**`;
            
            // Commenter la PR
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
              body: violation_message
            });
            
            // Fermer la PR
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr_number,
              state: 'closed'
            });
            
            // Ajouter un label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
              labels: ['tdd-violation', 'auto-closed']
            });