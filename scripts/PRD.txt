# **PRD Ojyx : Mise à Niveau Technique et Compilation (TDD-Driven)**

## **Overview**

Ce document définit les prochaines étapes techniques pour le projet Ojyx. L'objectif principal est de moderniser la base de code en **mettant à jour toutes les dépendances obsolètes** et de **garantir que l'application compile avec succès pour Android**. La réalisation de ces deux objectifs est un prérequis indispensable avant de reprendre le développement.

**L'ensemble du processus de développement suivra rigoureusement la méthodologie TDD (Test-Driven Development), détaillée en annexe, pour garantir la stabilité, la non-régression et la qualité du code.**

## **Core Tasks (Objectifs Principaux)**

Ce PRD se concentre sur deux tâches fondamentales, considérées ici comme les "features" à développer.

### **1\. Mise à Niveau des Dépendances**

* **Objectif** : Mettre à jour toutes les dépendances du projet (pubspec.yaml) vers leurs dernières versions stables.  
* **Importance** : Crucial pour la **sécurité**, la **performance** et la **compatibilité** future. Permet de bénéficier des dernières améliorations des librairies et de réduire la dette technique.  
* **Implémentation** :  
  1. Analyser les dépendances actuelles et leurs versions cibles.  
  2. Étudier les documentations pour identifier les "breaking changes".  
  3. Mettre à jour les dépendances de manière incrémentale.  
  4. Adapter le code existant en suivant un cycle TDD strict pour assurer la compatibilité.  
  5. Valider chaque mise à jour avec la suite de tests existante.

### **2\. Compilation Android Fonctionnelle**

* **Objectif** : Résoudre tous les problèmes de build pour générer un APK ou un App Bundle Android sans erreur.  
* **Importance** : C'est le livrable technique le plus élémentaire. Sans une build fonctionnelle, aucun test sur appareil réel, déploiement ou publication n'est possible.  
* **Implémentation** :  
  1. Lancer le processus de build Android et analyser les erreurs.  
  2. Écrire des tests (si applicable, pour des scripts de build custom) ou résoudre directement les erreurs de configuration Gradle et de SDK.  
  3. S'assurer de la compatibilité de la configuration avec la dernière version de Flutter et des dépendances mises à jour.

## **Technical Architecture**

### **Stack Actuelle**

* **Framework** : Flutter 3.x, Riverpod 2.x, Freezed, go\_router  
* **Backend** : Supabase (PostgreSQL, Realtime, Edge Functions)  
* **CI/CD** : GitHub Actions

### **Considérations pour la Mise à Niveau**

* La mise à jour de Flutter peut nécessiter des ajustements dans la configuration Android (Gradle, build.gradle, AndroidManifest.xml).  
* La mise à jour de Riverpod et go\_router entraînera très probablement des refactorings. **Chaque refactoring sera piloté par des tests** pour garantir que le comportement observable reste identique.  
* Il faudra s'assurer que la librairie cliente Supabase est compatible avec les autres dépendances mises à jour.

## **Development Roadmap**

### **Phase 1: Mise à Niveau des Dépendances (TDD-Driven)**

* **1.1 Audit & Analyse d'Impact**  
  * Lister toutes les dépendances et leurs versions actuelles et cibles.  
  * Lire les "changelogs" des dépendances majeures pour anticiper les modifications de code requises et les tests à adapter.  
* **1.2 Mise à Jour Incrémentale**  
  * Mettre à jour les dépendances par petits groupes logiques.  
  * Après chaque mise à jour, lancer la suite de tests pour voir ce qui échoue (Étape **Red** du cycle TDD).  
* **1.3 Adaptation du Code (Cycle Red-Green-Refactor)**  
  * **Application stricte du TDD** : Pour chaque adaptation nécessaire, le cycle Red-Green-Refactor sera appliqué.  
    * **Red** : Confirmer que les tests existants échouent comme prévu.  
    * **Green** : Écrire le code le plus simple pour que les tests passent.  
    * **Refactor** : Améliorer le code tout en s'assurant que les tests continuent de passer.  
  * Si le comportement d'une dépendance a changé, de **nouveaux tests seront écrits AVANT d'adapter le code** pour définir le nouveau comportement attendu.  
  * Se référer systématiquement au **Guide des Bonnes Pratiques TDD en Annexe B**.

### **Phase 2: Compilation Android**

* **2.1 Configuration de l'Environnement de Build**  
  * Vérifier que les versions du JDK et du SDK Android sont compatibles avec la nouvelle version de Flutter.  
  * Nettoyer le projet avec flutter clean.  
* **2.2 Résolution des Erreurs de Build**  
  * Lancer la commande flutter build apk \--debug.  
  * Analyser et corriger méthodiquement chaque erreur rapportée par Gradle.  
* **2.3 Validation**  
  * Obtenir une build Android qui s'exécute avec succès.  
  * Installer et lancer l'APK sur un émulateur ou un appareil physique pour confirmer son fonctionnement.

## **Logical Dependency Chain**

1. **Mise à Niveau des Dépendances (Phase 1\)** : Une base de code stable et testée est nécessaire avant de tenter de la compiler.  
2. **Compilation Android (Phase 2\)** : Le succès de la compilation dépend directement de la résolution des conflits de la phase 1\.

L'objectif est de terminer la Phase 1 avant d'entamer la Phase 2\.

## **Risks and Mitigations**

* **Risque** : "Dependency Hell" – des conflits de versions insolubles entre les paquets.  
  * **Mitigation** : Utiliser des contraintes de version flexibles (^) et analyser l'arbre de dépendances avec dart pub deps. Procéder par mises à jour atomiques pour isoler les problèmes.  
* **Risque** : La mise à jour d'une dépendance majeure casse une grande partie de l'application.  
  * **Mitigation** : Dédier une branche Git spécifique. **S'appuyer sur le cycle TDD et la suite de tests existante pour valider chaque micro-changement**, garantissant la non-régression de manière systématique, comme défini dans le guide en annexe.  
* **Risque** : Les erreurs de build Android sont natives et difficiles à déboguer.  
  * **Mitigation** : Consulter la documentation officielle de Flutter. Isoler le problème en créant un projet Flutter vierge avec les mêmes dépendances pour voir s'il persiste.

## **Annexes**

### **Annexe A : Commandes et Règles Générales**

#### **Règles de Développement**

* **TDD Obligatoire** : Tout nouveau code ou adaptation doit commencer par un test qui échoue.  
* **Commits Atomiques** : Commiter chaque mise à jour ou correction de manière isolée.  
* **CI/CD** : S'assurer que la CI passe après chaque phase de refactoring.

#### **Commandes Essentielles**

\# Vérifier les dépendances obsolètes  
flutter pub outdated

\# Mettre à jour les dépendances  
flutter pub upgrade

\# Lancer la suite de tests  
flutter test

\# Compiler pour Android  
flutter build apk \--debug

### **Annexe B : Guide des Bonnes Pratiques TDD \- Projet Ojyx**

#### **Les 5 Principes Fondamentaux du TDD**

##### **1\. 🎯 Tester le Comportement, pas l'Implémentation**

**✅ Bon :** Tester ce qui est observable

test('should enable strategic card exchange for competitive advantage', () {  
  // Test behavior: card exchange creates new strategic opportunities  
  final result \= useCase.exchangeCards(position1, position2);  
  expect(result.strategicValue, greaterThan(previousValue));  
});

##### **2\. 🔄 Éliminer la Redondance**

**✅ Bon :** Tests paramétrés avec scénarios significatifs

test('should scale competitive dynamics across different player counts', () {  
  final scenarios \= \[  
    (players: 2, dynamics: 'intense duel', complexity: 'low'),  
    (players: 4, dynamics: 'strategic alliances', complexity: 'medium'),  
    (players: 8, dynamics: 'chaotic competition', complexity: 'high'),  
  \];  
   
  for (final scenario in scenarios) {  
    // Test the behavioral differences at each scale  
  }  
});

##### **3\. 🛡️ Isoler le Code avec des Mocks**

**✅ Bon :** Mocks qui simulent des comportements externes

when(() \=\> mockNetworkService.isConnected).thenReturn(false);  
// Test how the system behaves when network is unavailable

##### **4\. 📏 Assurer une Bonne Granularité**

**✅ Bon :** Tests qui vérifient des comportements métier

test('should prevent card selection during opponent turn for fair play', () {  
  final gameState \= TestGameStateBuilder()  
    .withCurrentPlayer('opponent-id')  
    .build();  
      
  final canSelect \= selectionPolicy.canSelectCard(gameState, 'my-id');  
  expect(canSelect, isFalse, reason: 'Turn-based fairness must be enforced');  
});

##### **5\. 📖 Favoriser la Lisibilité et la Clarté**

**✅ Bon :** Noms expressifs et données métier

test('should trigger strategic reshuffle when deck exhausted mid-game', () {  
  // Given: A competitive game nearing deck exhaustion  
  final gameState \= TestGameStateBuilder()  
    .inLastRound()  
    .withPartialDeck(2)  
    .build();  
      
  // When: Player attempts to draw with insufficient cards  
  final result \= drawCardUseCase(gameState);  
   
  // Then: System maintains game continuity through reshuffle  
  expect(result.deck, hasLength(greaterThan(2)));  
  expect(result.continuityMaintained, isTrue);  
});

#### **Format Standard des Tests**

* **Nomenclature** : 'should \[expected behavior\] when \[condition/context\]'  
* **Structure AAA (Arrange-Act-Assert)**

#### **Utilisation des Test Builders**

final player \= TestGamePlayerBuilder()  
  .withId('strategic-player')  
  .withRevealedGrid(revealedCount: 6\)  
  .withActionCards(\[  
    TestActionCardBuilder().asTeleport().build(),  
    TestActionCardBuilder().asSwap().build(),  
  \])  
  .asHost()  
  .build();

#### **Custom Matchers Métier**

expect(gameState, isPlaying);  
expect(gameState, hasPlayerCount(4));  
expect(player.grid, hasAllCardsRevealed);

#### **Anti-patterns à Éviter**

1. ❌ **Ne JAMAIS commenter des tests** \-\> Corriger ou supprimer.  
2. ❌ **Éviter les tests qui testent le framework** \-\> Tester votre logique, pas celle de Flutter.  
3. ❌ **Ne pas mocker les entités métier** \-\> Utiliser les builders pour créer de vraies entités.

#### **Checklist Pré-Commit**

* \[ \] Tous les tests suivent la nomenclature standard.  
* \[ \] Utilisation des test builders pour réduire la duplication.  
* \[ \] Custom matchers pour les assertions métier.  
* \[ \] Aucun test commenté.  
* \[ \] Coverage minimum de 80% sur le nouveau code / code adapté.  
* \[ \] Les tests racontent une histoire claire sur le comportement attendu.