# **PRD Ojyx : Mise √† Niveau Technique et Compilation (TDD-Driven)**

## **Overview**

Ce document d√©finit les prochaines √©tapes techniques pour le projet Ojyx. L'objectif principal est de moderniser la base de code en **mettant √† jour toutes les d√©pendances obsol√®tes** et de **garantir que l'application compile avec succ√®s pour Android**. La r√©alisation de ces deux objectifs est un pr√©requis indispensable avant de reprendre le d√©veloppement.

**L'ensemble du processus de d√©veloppement suivra rigoureusement la m√©thodologie TDD (Test-Driven Development), d√©taill√©e en annexe, pour garantir la stabilit√©, la non-r√©gression et la qualit√© du code.**

## **Core Tasks (Objectifs Principaux)**

Ce PRD se concentre sur deux t√¢ches fondamentales, consid√©r√©es ici comme les "features" √† d√©velopper.

### **1\. Mise √† Niveau des D√©pendances**

* **Objectif** : Mettre √† jour toutes les d√©pendances du projet (pubspec.yaml) vers leurs derni√®res versions stables.  
* **Importance** : Crucial pour la **s√©curit√©**, la **performance** et la **compatibilit√©** future. Permet de b√©n√©ficier des derni√®res am√©liorations des librairies et de r√©duire la dette technique.  
* **Impl√©mentation** :  
  1. Analyser les d√©pendances actuelles et leurs versions cibles.  
  2. √âtudier les documentations pour identifier les "breaking changes".  
  3. Mettre √† jour les d√©pendances de mani√®re incr√©mentale.  
  4. Adapter le code existant en suivant un cycle TDD strict pour assurer la compatibilit√©.  
  5. Valider chaque mise √† jour avec la suite de tests existante.

### **2\. Compilation Android Fonctionnelle**

* **Objectif** : R√©soudre tous les probl√®mes de build pour g√©n√©rer un APK ou un App Bundle Android sans erreur.  
* **Importance** : C'est le livrable technique le plus √©l√©mentaire. Sans une build fonctionnelle, aucun test sur appareil r√©el, d√©ploiement ou publication n'est possible.  
* **Impl√©mentation** :  
  1. Lancer le processus de build Android et analyser les erreurs.  
  2. √âcrire des tests (si applicable, pour des scripts de build custom) ou r√©soudre directement les erreurs de configuration Gradle et de SDK.  
  3. S'assurer de la compatibilit√© de la configuration avec la derni√®re version de Flutter et des d√©pendances mises √† jour.

## **Technical Architecture**

### **Stack Actuelle**

* **Framework** : Flutter 3.x, Riverpod 2.x, Freezed, go\_router  
* **Backend** : Supabase (PostgreSQL, Realtime, Edge Functions)  
* **CI/CD** : GitHub Actions

### **Consid√©rations pour la Mise √† Niveau**

* La mise √† jour de Flutter peut n√©cessiter des ajustements dans la configuration Android (Gradle, build.gradle, AndroidManifest.xml).  
* La mise √† jour de Riverpod et go\_router entra√Ænera tr√®s probablement des refactorings. **Chaque refactoring sera pilot√© par des tests** pour garantir que le comportement observable reste identique.  
* Il faudra s'assurer que la librairie cliente Supabase est compatible avec les autres d√©pendances mises √† jour.

## **Development Roadmap**

### **Phase 1: Mise √† Niveau des D√©pendances (TDD-Driven)**

* **1.1 Audit & Analyse d'Impact**  
  * Lister toutes les d√©pendances et leurs versions actuelles et cibles.  
  * Lire les "changelogs" des d√©pendances majeures pour anticiper les modifications de code requises et les tests √† adapter.  
* **1.2 Mise √† Jour Incr√©mentale**  
  * Mettre √† jour les d√©pendances par petits groupes logiques.  
  * Apr√®s chaque mise √† jour, lancer la suite de tests pour voir ce qui √©choue (√âtape **Red** du cycle TDD).  
* **1.3 Adaptation du Code (Cycle Red-Green-Refactor)**  
  * **Application stricte du TDD** : Pour chaque adaptation n√©cessaire, le cycle Red-Green-Refactor sera appliqu√©.  
    * **Red** : Confirmer que les tests existants √©chouent comme pr√©vu.  
    * **Green** : √âcrire le code le plus simple pour que les tests passent.  
    * **Refactor** : Am√©liorer le code tout en s'assurant que les tests continuent de passer.  
  * Si le comportement d'une d√©pendance a chang√©, de **nouveaux tests seront √©crits AVANT d'adapter le code** pour d√©finir le nouveau comportement attendu.  
  * Se r√©f√©rer syst√©matiquement au **Guide des Bonnes Pratiques TDD en Annexe B**.

### **Phase 2: Compilation Android**

* **2.1 Configuration de l'Environnement de Build**  
  * V√©rifier que les versions du JDK et du SDK Android sont compatibles avec la nouvelle version de Flutter.  
  * Nettoyer le projet avec flutter clean.  
* **2.2 R√©solution des Erreurs de Build**  
  * Lancer la commande flutter build apk \--debug.  
  * Analyser et corriger m√©thodiquement chaque erreur rapport√©e par Gradle.  
* **2.3 Validation**  
  * Obtenir une build Android qui s'ex√©cute avec succ√®s.  
  * Installer et lancer l'APK sur un √©mulateur ou un appareil physique pour confirmer son fonctionnement.

## **Logical Dependency Chain**

1. **Mise √† Niveau des D√©pendances (Phase 1\)** : Une base de code stable et test√©e est n√©cessaire avant de tenter de la compiler.  
2. **Compilation Android (Phase 2\)** : Le succ√®s de la compilation d√©pend directement de la r√©solution des conflits de la phase 1\.

L'objectif est de terminer la Phase 1 avant d'entamer la Phase 2\.

## **Risks and Mitigations**

* **Risque** : "Dependency Hell" ‚Äì des conflits de versions insolubles entre les paquets.  
  * **Mitigation** : Utiliser des contraintes de version flexibles (^) et analyser l'arbre de d√©pendances avec dart pub deps. Proc√©der par mises √† jour atomiques pour isoler les probl√®mes.  
* **Risque** : La mise √† jour d'une d√©pendance majeure casse une grande partie de l'application.  
  * **Mitigation** : D√©dier une branche Git sp√©cifique. **S'appuyer sur le cycle TDD et la suite de tests existante pour valider chaque micro-changement**, garantissant la non-r√©gression de mani√®re syst√©matique, comme d√©fini dans le guide en annexe.  
* **Risque** : Les erreurs de build Android sont natives et difficiles √† d√©boguer.  
  * **Mitigation** : Consulter la documentation officielle de Flutter. Isoler le probl√®me en cr√©ant un projet Flutter vierge avec les m√™mes d√©pendances pour voir s'il persiste.

## **Annexes**

### **Annexe A : Commandes et R√®gles G√©n√©rales**

#### **R√®gles de D√©veloppement**

* **TDD Obligatoire** : Tout nouveau code ou adaptation doit commencer par un test qui √©choue.  
* **Commits Atomiques** : Commiter chaque mise √† jour ou correction de mani√®re isol√©e.  
* **CI/CD** : S'assurer que la CI passe apr√®s chaque phase de refactoring.

#### **Commandes Essentielles**

\# V√©rifier les d√©pendances obsol√®tes  
flutter pub outdated

\# Mettre √† jour les d√©pendances  
flutter pub upgrade

\# Lancer la suite de tests  
flutter test

\# Compiler pour Android  
flutter build apk \--debug

### **Annexe B : Guide des Bonnes Pratiques TDD \- Projet Ojyx**

#### **Les 5 Principes Fondamentaux du TDD**

##### **1\. üéØ Tester le Comportement, pas l'Impl√©mentation**

**‚úÖ Bon :** Tester ce qui est observable

test('should enable strategic card exchange for competitive advantage', () {  
  // Test behavior: card exchange creates new strategic opportunities  
  final result \= useCase.exchangeCards(position1, position2);  
  expect(result.strategicValue, greaterThan(previousValue));  
});

##### **2\. üîÑ √âliminer la Redondance**

**‚úÖ Bon :** Tests param√©tr√©s avec sc√©narios significatifs

test('should scale competitive dynamics across different player counts', () {  
  final scenarios \= \[  
    (players: 2, dynamics: 'intense duel', complexity: 'low'),  
    (players: 4, dynamics: 'strategic alliances', complexity: 'medium'),  
    (players: 8, dynamics: 'chaotic competition', complexity: 'high'),  
  \];  
   
  for (final scenario in scenarios) {  
    // Test the behavioral differences at each scale  
  }  
});

##### **3\. üõ°Ô∏è Isoler le Code avec des Mocks**

**‚úÖ Bon :** Mocks qui simulent des comportements externes

when(() \=\> mockNetworkService.isConnected).thenReturn(false);  
// Test how the system behaves when network is unavailable

##### **4\. üìè Assurer une Bonne Granularit√©**

**‚úÖ Bon :** Tests qui v√©rifient des comportements m√©tier

test('should prevent card selection during opponent turn for fair play', () {  
  final gameState \= TestGameStateBuilder()  
    .withCurrentPlayer('opponent-id')  
    .build();  
      
  final canSelect \= selectionPolicy.canSelectCard(gameState, 'my-id');  
  expect(canSelect, isFalse, reason: 'Turn-based fairness must be enforced');  
});

##### **5\. üìñ Favoriser la Lisibilit√© et la Clart√©**

**‚úÖ Bon :** Noms expressifs et donn√©es m√©tier

test('should trigger strategic reshuffle when deck exhausted mid-game', () {  
  // Given: A competitive game nearing deck exhaustion  
  final gameState \= TestGameStateBuilder()  
    .inLastRound()  
    .withPartialDeck(2)  
    .build();  
      
  // When: Player attempts to draw with insufficient cards  
  final result \= drawCardUseCase(gameState);  
   
  // Then: System maintains game continuity through reshuffle  
  expect(result.deck, hasLength(greaterThan(2)));  
  expect(result.continuityMaintained, isTrue);  
});

#### **Format Standard des Tests**

* **Nomenclature** : 'should \[expected behavior\] when \[condition/context\]'  
* **Structure AAA (Arrange-Act-Assert)**

#### **Utilisation des Test Builders**

final player \= TestGamePlayerBuilder()  
  .withId('strategic-player')  
  .withRevealedGrid(revealedCount: 6\)  
  .withActionCards(\[  
    TestActionCardBuilder().asTeleport().build(),  
    TestActionCardBuilder().asSwap().build(),  
  \])  
  .asHost()  
  .build();

#### **Custom Matchers M√©tier**

expect(gameState, isPlaying);  
expect(gameState, hasPlayerCount(4));  
expect(player.grid, hasAllCardsRevealed);

#### **Anti-patterns √† √âviter**

1. ‚ùå **Ne JAMAIS commenter des tests** \-\> Corriger ou supprimer.  
2. ‚ùå **√âviter les tests qui testent le framework** \-\> Tester votre logique, pas celle de Flutter.  
3. ‚ùå **Ne pas mocker les entit√©s m√©tier** \-\> Utiliser les builders pour cr√©er de vraies entit√©s.

#### **Checklist Pr√©-Commit**

* \[ \] Tous les tests suivent la nomenclature standard.  
* \[ \] Utilisation des test builders pour r√©duire la duplication.  
* \[ \] Custom matchers pour les assertions m√©tier.  
* \[ \] Aucun test comment√©.  
* \[ \] Coverage minimum de 80% sur le nouveau code / code adapt√©.  
* \[ \] Les tests racontent une histoire claire sur le comportement attendu.