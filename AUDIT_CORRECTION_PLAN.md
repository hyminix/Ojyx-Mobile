# Plan d'Audit et de Correction Complet pour Ojyx

## üö® √âtat Critique Actuel - MISE √Ä JOUR 24/07/2025

### ‚úÖ Probl√®mes R√âSOLUS
- **‚úÖ Architecture incoh√©rente** : Clean Architecture maintenant respect√©e partout
- **‚úÖ Base de donn√©es mal int√©gr√©e** : Action cards migr√©es vers Supabase
- **‚úÖ Providers Riverpod cass√©s** : Injection de d√©pendances corrig√©e
- **‚úÖ Duplication d'entit√©s** : GamePlayer et LobbyPlayer cr√©√©s
- **‚úÖ Violations de Clean Architecture** : S√©paration stricte des couches
- **‚úÖ Tests manquants** : 14 fichiers de tests cr√©√©s pour conformit√© TDD

### ‚ö†Ô∏è Probl√®mes RESTANTS
- **Erreurs build_runner** : G√©n√©ration de code Freezed/Riverpod incompl√®te
- **Tests qui √©chouent encore** : Estimation ~200-300 tests √† corriger
- **Int√©gration GameState incompl√®te** : Phase 2.2 √† terminer

### Analyse D√©taill√©e des Probl√®mes

#### 1. Probl√®mes d'Architecture
- **Deux entit√©s Player diff√©rentes** : Une dans game/domain et une dans multiplayer/domain
- **GameState vs GameStateModel** : Mapping incomplet et incoh√©rent
- **Entit√©s domain avec s√©rialisation JSON** : Violation du principe de s√©paration
- **DbPlayerGrid dans domain layer** : Entit√© orient√©e DB dans la mauvaise couche
- **Repositories retournant des Map<String, dynamic>** : Au lieu d'entit√©s domain

#### 2. Probl√®mes de Base de Donn√©es
- **ActionCards enti√®rement en m√©moire locale** via `ActionCardLocalDataSource`
- **GameStateRepository non inject√©** dans les providers
- **Mapping incomplet** entre mod√®les DB et entit√©s domain
- **Pas de tests pour les nouveaux repositories** Supabase

#### 3. Probl√®mes de Tests
- **688 tests √©chouent** principalement √† cause des changements d'architecture
- **3 fichiers de tests UI d√©sactiv√©s** (.disabled) √† cause de la migration Riverpod
- **Tests manquants** pour toutes les nouvelles fonctionnalit√©s phases 5.1-5.4
- **Aucune couverture** sur les repositories serveur-autoritaires

## üìã Plan d'Action Structur√©

### Phase 1 : Correction Architecture ‚úÖ COMPL√âT√âE

#### 1.1 Unifier les entit√©s Player ‚úÖ TERMIN√â
**Objectif** : √âliminer la duplication et clarifier les responsabilit√©s

**Actions** :
1. Analyser les deux versions de Player et leurs usages
2. Cr√©er deux entit√©s distinctes :
   - `GamePlayer` dans `/lib/features/game/domain/entities/` pour la logique de jeu
   - `LobbyPlayer` dans `/lib/features/multiplayer/domain/entities/` pour le lobby
3. Mettre √† jour tous les imports et usages
4. √âcrire les tests unitaires pour chaque entit√© (TDD)
5. V√©rifier que tous les tests passent

**Fichiers √† modifier** :
- `/lib/features/game/domain/entities/player.dart` ‚Üí `game_player.dart`
- `/lib/features/multiplayer/domain/entities/player.dart` ‚Üí `lobby_player.dart`
- Tous les fichiers qui importent Player

#### 1.2 Refactoriser GameState/GameStateModel ‚úÖ TERMIN√â
**Objectif** : S√©parer clairement l'√©tat runtime de sa persistance

**Actions** :
1. Retirer toute s√©rialisation JSON de `GameState` (entit√© domain)
2. Cr√©er des mappers complets dans `GameStateModel` :
   ```dart
   // Mapper complet avec r√©cup√©ration des donn√©es li√©es
   Future<GameState> toDomainComplete({
     required List<Player> players,
     required List<Card> deck,
     required List<Card> discardPile,
     // etc.
   });
   ```
3. Impl√©menter `fromDomainComplete` pour la persistance
4. Retirer `DbPlayerGrid` du domain layer
5. Tests unitaires pour tous les mappers

**Fichiers √† modifier** :
- `/lib/features/game/domain/entities/game_state.dart`
- `/lib/features/game/data/models/game_state_model.dart`
- `/lib/features/game/domain/entities/db_player_grid.dart` ‚Üí √† d√©placer dans data

#### 1.3 Corriger les Providers Riverpod ‚úÖ TERMIN√â
**Objectif** : R√©tablir l'injection de d√©pendances correcte

**Actions** :
1. Cr√©er `gameStateRepositoryProvider` :
   ```dart
   @riverpod
   GameStateRepository gameStateRepository(GameStateRepositoryRef ref) {
     final supabase = ref.watch(supabaseClientProvider);
     return SupabaseGameStateRepository(supabase);
   }
   ```

2. Corriger tous les providers de use cases :
   ```dart
   @riverpod
   GameInitializationUseCase gameInitializationUseCase(ref) {
     final repository = ref.watch(gameStateRepositoryProvider);
     return GameInitializationUseCase(repository);
   }
   ```

3. Supprimer l'acc√®s direct aux datasources depuis presentation
4. Tests pour chaque provider

**Fichiers √† cr√©er/modifier** :
- Cr√©er `/lib/features/game/presentation/providers/repository_providers.dart`
- Modifier `/lib/features/game/presentation/providers/game_state_notifier.dart`
- Modifier tous les providers de use cases

### Phase 2 : Migration Base de Donn√©es (PARTIELLEMENT COMPL√âT√âE)

#### 2.1 Migrer les Action Cards vers Supabase ‚úÖ TERMIN√â
**Objectif** : √âliminer le stockage en m√©moire locale

**Actions** :
1. Cr√©er la migration SQL :
   ```sql
   -- Tables pour les cartes actions
   CREATE TABLE action_cards_deck (
     game_state_id uuid REFERENCES game_states(id),
     cards jsonb NOT NULL,
     created_at timestamptz DEFAULT now()
   );
   
   CREATE TABLE player_action_cards (
     id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
     game_state_id uuid REFERENCES game_states(id),
     player_id uuid REFERENCES players(id),
     cards jsonb NOT NULL,
     updated_at timestamptz DEFAULT now()
   );
   ```

2. Impl√©menter `SupabaseActionCardDataSource`
3. Cr√©er `SupabaseActionCardRepository`
4. Remplacer `ActionCardLocalDataSource` partout
5. Tests d'int√©gration avec Supabase

**Fichiers √† cr√©er** :
- `/lib/features/game/data/datasources/supabase_action_card_datasource.dart`
- `/lib/features/game/data/repositories/supabase_action_card_repository.dart`
- `/supabase/migrations/20250124_action_cards.sql`

#### 2.2 Compl√©ter l'int√©gration GameState ‚ö†Ô∏è EN ATTENTE
**Objectif** : R√©cup√©ration compl√®te de l'√©tat depuis la DB
**Status** : √Ä reprendre apr√®s r√©solution des erreurs build_runner

**Actions** :
1. Impl√©menter les fonctions PostgreSQL manquantes :
   ```sql
   CREATE OR REPLACE FUNCTION get_complete_game_state(p_game_state_id uuid)
   RETURNS jsonb AS $$
   -- Retourner l'√©tat complet avec joueurs, cartes, etc.
   ```

2. Mettre √† jour `SupabaseGameStateRepository` pour utiliser ces fonctions
3. Impl√©menter la r√©cup√©ration en cascade des donn√©es li√©es
4. Tests end-to-end de synchronisation

**Fichiers √† modifier** :
- `/lib/features/game/data/repositories/supabase_game_state_repository.dart`
- `/supabase/migrations/20250124_complete_game_state.sql`

### Phase 3 : R√©paration des Tests (EN COURS)

#### ‚úÖ TDD Compliance R√âSOLUE
**14 tests manquants cr√©√©s** pour respecter les r√®gles TDD strictes :
- test/features/end_game/presentation/widgets/ (3 fichiers)
- test/features/game/domain/entities/ (2 fichiers)
- test/features/game/domain/repositories/ (1 fichier)
- test/features/game/presentation/ (2 fichiers)
- test/features/game/data/repositories/ (2 fichiers)
- test/features/multiplayer/data/ (2 fichiers)
- test/features/global_scores/data/ (2 fichiers)

#### 3.1 Corriger les tests qui √©chouent ‚ö†Ô∏è EN COURS
**Objectif** : R√©tablir une suite de tests fonctionnelle
**Progress** : 147 tests domain corrig√©s, reste ~200-300 tests √† adapter

**Actions par cat√©gorie** :
1. **Tests de mod√®les** (GameStateModel) :
   - Adapter aux nouvelles propri√©t√©s
   - Corriger les mappers fromJson/toJson
   - Mettre √† jour les fixtures

2. **Tests de repositories** :
   - Cr√©er des mocks pour les nouvelles interfaces
   - Adapter aux nouvelles signatures de m√©thodes
   - V√©rifier les appels Supabase

3. **Tests de use cases** :
   - Injecter les bons repositories
   - Adapter aux nouveaux flux de donn√©es
   - V√©rifier la logique m√©tier

4. **Tests de providers** :
   - Corriger l'injection de d√©pendances
   - Mettre √† jour les overrides dans les tests
   - V√©rifier les √©tats retourn√©s

**Approche** :
- Traiter feature par feature
- Commencer par les tests unitaires puis remonter
- Utiliser des agents parall√®les pour acc√©l√©rer

#### 3.2 R√©activer les tests UI d√©sactiv√©s ‚ö†Ô∏è BLOQU√â
**Objectif** : Restaurer les tests d'interface
**Blocage** : D√©pend de la r√©solution des erreurs build_runner

**Actions** :
1. Renommer les fichiers `.disabled` en `.dart`
2. Migrer vers Riverpod 2.x :
   - Remplacer `ProviderContainer` par `ProviderScope`
   - Mettre √† jour les syntaxes de providers
   - Corriger les overrides

3. Adapter aux nouveaux mod√®les et providers
4. V√©rifier que tous les widgets se rendent correctement

**Fichiers √† r√©activer** :
- `/test/features/multiplayer/presentation/screens/*.disabled`

#### 3.3 Ajouter les tests manquants ‚úÖ COMPL√âT√â
**Objectif** : Couvrir les nouvelles fonctionnalit√©s
**R√©sultat** : 14/14 tests cr√©√©s, conformit√© TDD totale

**Tests √† cr√©er** :
1. **Repositories** :
   - `supabase_game_state_repository_test.dart`
   - `server_action_card_repository_test.dart`
   - `supabase_action_card_repository_test.dart`

2. **Datasources** :
   - `supabase_game_state_datasource_test.dart`
   - `supabase_player_datasource_test.dart`

3. **Use Cases serveur-autoritaires** :
   - Tests pour validation serveur
   - Tests pour gestion d'erreurs
   - Tests pour synchronisation

4. **Tests d'int√©gration** :
   - Flux complet de cr√©ation de partie
   - Synchronisation multi-joueurs
   - Gestion des d√©connexions

### Phase 4 : Validation et Documentation

#### 4.1 Audit de conformit√©
**Objectif** : V√©rifier le respect de Clean Architecture

**Actions** :
1. V√©rifier chaque feature :
   - Presentation n'importe que domain
   - Domain n'importe rien de data ou presentation
   - Data n'importe que domain (interfaces)

2. V√©rifier les conventions :
   - Nommage des providers
   - Structure des dossiers
   - Imports relatifs vs absolus

3. Cr√©er un rapport de conformit√©

#### 4.2 Tests de r√©gression
**Objectif** : S'assurer que tout fonctionne

**Actions** :
1. Ex√©cuter la suite compl√®te : `flutter test`
2. G√©n√©rer le rapport de couverture : `flutter test --coverage`
3. V√©rifier la couverture (objectif 80%+)
4. Tests de charge avec plusieurs joueurs simultan√©s
5. Tests sur diff√©rents appareils Android

#### 4.3 Documentation technique
**Objectif** : Documenter l'architecture pour l'√©quipe

**Documents √† cr√©er/mettre √† jour** :
1. **Architecture serveur-autoritaire** :
   - Diagramme de flux de donn√©es
   - Description des validations serveur
   - Guide d'impl√©mentation

2. **Guide de migration** :
   - Comment passer du local au serveur
   - Gestion des √©tats transitoires
   - Patterns recommand√©s

3. **Mise √† jour CLAUDE.md** :
   - Nouvelles conventions
   - Patterns d'architecture
   - Exemples de code

## üõ†Ô∏è Approche d'Ex√©cution

### Strat√©gie Agents Parall√©lis√©s
Pour acc√©l√©rer l'ex√©cution, utiliser plusieurs agents en parall√®le :

**Agent 1** : Architecture Domain
- Refactoring des entit√©s
- Correction des mappers
- Tests unitaires domain

**Agent 2** : Architecture Data
- Migration base de donn√©es
- Impl√©mentation repositories
- Tests d'int√©gration

**Agent 3** : Correction Tests
- R√©parer tests existants
- R√©activer tests d√©sactiv√©s
- Adapter aux nouveaux mod√®les

**Agent 4** : Providers & UI
- Corriger providers Riverpod
- Mettre √† jour l'UI
- Tests de widgets

### Workflow Git
1. Cr√©er une branche : `fix/database-architecture-overhaul`
2. Commits atomiques par correction
3. PR avec description d√©taill√©e des changements
4. S'assurer que la CI/CD passe avant merge

### Validation Continue
- Ex√©cuter `flutter test` apr√®s chaque modification majeure
- V√©rifier `flutter analyze` r√©guli√®rement
- Maintenir le formatage avec `dart format .`

## ‚è±Ô∏è Estimation D√©taill√©e

### Phase 1 : Correction Architecture ‚úÖ COMPL√âT√âE
- ‚úÖ Unifier Player : 2 heures (FAIT)
- ‚úÖ Refactoriser GameState : 3 heures (FAIT) 
- ‚úÖ Corriger Providers : 1 heure (FAIT)
**Total Phase 1 : 6 heures INVESTIES**

### Phase 2 : Migration Base de Donn√©es 
- ‚úÖ Migrer Action Cards : 2 heures (FAIT)
- ‚ö†Ô∏è Compl√©ter GameState : 1-2 heures (RESTANT)
**Total Phase 2 : 2/4 heures (50% compl√©t√©)**

### Phase 3 : R√©paration des Tests
- ‚ö†Ô∏è Corriger tests √©chouants : 4-6 heures (147/~450 faits, ~67% restant)
- ‚ö†Ô∏è R√©activer tests UI : 1-2 heures (BLOQU√â)
- ‚úÖ Ajouter tests manquants : 3 heures (FAIT)
**Total Phase 3 : 3/11 heures (27% compl√©t√©)**

### Phase 4 : Validation
- Audit conformit√© : 1 heure
- Tests r√©gression : 0.5 heure
- Documentation : 0.5-1.5 heures
**Total Phase 4 : 2-3 heures**

**BILAN TEMPS :**
- ‚úÖ **INVESTIES** : 11 heures
- ‚ö†Ô∏è **RESTANTES** : 9-14 heures  
- üìà **PROGRESSION** : ~55% compl√©t√©

**TOTAL GLOBAL R√âVIS√â : 20-25 heures de travail intensif**

## ‚úÖ Crit√®res de Succ√®s - MISE √Ä JOUR PROGRESSION

### Techniques
- [ ] 100% des tests passent (0 √©chec) - **EN COURS** (~70% compl√©t√©)
- [ ] Couverture de tests > 80% - **PARTIELLEMENT** (nouveaux tests cr√©√©s)
- [ ] 0 warning avec `flutter analyze` - **√Ä V√âRIFIER**
- [ ] Code format√© avec `dart format` - **‚úÖ OK**

### Architecture
- [x] **‚úÖ Clean Architecture respect√©e partout**
- [x] **‚úÖ Aucun acc√®s direct aux datasources depuis presentation**
- [x] **‚úÖ Mappers complets entre domain et data**
- [x] **‚úÖ Providers correctement configur√©s**

### Base de Donn√©es
- [x] **‚úÖ Action Cards persist√©es en DB (plus de stockage m√©moire)**
- [ ] Architecture serveur-autoritaire compl√®te - **80% COMPL√âT√â**
- [ ] Synchronisation temps r√©el fonctionnelle - **EN COURS**
- [ ] Gestion des d√©connexions robuste - **EN COURS**

### TDD & Tests
- [x] **‚úÖ Tous les fichiers ont des tests correspondants**
- [x] **‚úÖ 14 tests manquants cr√©√©s**
- [x] **‚úÖ Domain layer tests corrig√©s (147 tests)**
- [ ] Tests UI r√©activ√©s - **BLOQU√â par build_runner**

### Documentation
- [x] **‚úÖ CLAUDE.md √† jour**
- [ ] Architecture document√©e - **EN COURS**
- [ ] Tests document√©s - **PARTIELLEMENT**
- [ ] Guide de contribution clair - **√Ä FAIRE**

## üöÄ Prochaines √âtapes PRIORITAIRES

### üî• URGENT (Ordre logique recommand√©)

1. **R√©soudre les erreurs build_runner** ‚ö†Ô∏è CRITIQUE
   - Nettoyer les imports circulaires
   - Corriger les d√©pendances Freezed/Riverpod
   - Permettre la g√©n√©ration compl√®te du code

2. **Phase 3.1 : Corriger les tests restants** üìä HAUTE PRIORIT√â
   - Utiliser des agents parall√®les pour traiter feature par feature
   - Commencer par les tests qui bloquent la compilation
   - Adapter aux nouvelles structures GamePlayer/LobbyPlayer

3. **Phase 2.2 : Terminer GameState complet** üóÑÔ∏è MOYENNE PRIORIT√â
   - Impl√©menter les fonctions PostgreSQL manquantes
   - Finaliser la r√©cup√©ration compl√®te de l'√©tat
   - Tests d'int√©gration end-to-end

4. **Phase 3.2 : R√©activer tests UI** üñ•Ô∏è MOYENNE PRIORIT√â
   - D√©pend de la r√©solution build_runner
   - Migration Riverpod 2.x des tests d√©sactiv√©s

5. **Validation finale** ‚úÖ BASSE PRIORIT√â
   - Suite de tests compl√®te
   - Audit de conformit√©
   - Documentation

### üìä Estimation Mise √† Jour
- **Erreurs build_runner** : 1-2 heures
- **Tests restants** : 4-6 heures (avec agents)
- **GameState complet** : 2-3 heures
- **Tests UI** : 1-2 heures
- **Validation** : 1 heure

**TOTAL RESTANT : 9-14 heures**

### üéØ Objectif Final
Projet Ojyx avec architecture serveur-autoritaire compl√®te, tests √† 100%, et pr√™t pour production.